searchState.loadedDescShard("etherparse", 0, "A zero allocation library for parsing &amp; writing a bunch of …\nActive Networks [Bob_Braden]\nany distributed file system …\nany host internal protocol …\nany local network [Internet_Assigned_Numbers_Authority]\nany 0-hop protocol [Internet_Assigned_Numbers_Authority]\nARGUS (deprecated) [Robert_W_Scheifler]\nARIS [Nancy_Feldman]\nAuthentication Header [RFC4302]\nAX.25 Frames [Brian_Kantor]\nAuthentication Header [RFC4302]\nBBN RCC Monitoring [Steve_Chipman]\nBNA [Gary Salamon]\nBackroom SATNET Monitoring [Steven_Blumenthal]\nCBT [Tony_Ballardie]\nCFTP [Forsdick, H., “CFTP”, Network Message, Bolt …\nChaos [J_Noel_Chiappa]\nCompaq Peer Protocol [Victor_Volpe]\nComputer Protocol Heart Beat [David Mittnacht]\nComputer Protocol Network Executive [David Mittnacht]\nCombat Radio Transport Protocol [Robert_Sautter]\nCombat Radio User Datagram [Robert_Sautter]\nDatagram Congestion Control Protocol [RFC4340]\nDCN Measurement Subsystems [David_Mills]\nDatagram Delivery Protocol [Wesley_Craig]\nD-II Data Exchange (DDX) [John_Worley]\nDissimilar Gateway Protocol [M/A-COM Government Systems, …\nDynamic Source Routing Protocol [RFC4728]\nDestination Options for IPv6 [RFC8200]\nMessage sent to inform the client that the destination is …\nMessage sent to inform the client that the destination is …\nIEEE 802.1Q double VLAN Tagging Header\nError while parsing a double vlan header.\nIEEE 802.1Q double VLAN Tagging Header\nA slice containing an double vlan header of a network …\nSlice containing a VLAN header &amp; payload.\nExterior Gateway Protocol [RFC888] [David_Mills]\nEIGRP [RFC7868]\nEMCON [mystery contact]\nEncapsulation Header [RFC1241][Robert_Woodburn]\nEncapsulating Security Payload [RFC4303]\nEthernet-within-IP Encapsulation [RFC3378]\nUse for experimentation and testing\nUse for experimentation and testing\nResponse to an <code>EchoRequest</code> message (defined in RFC792).\nResponse to an <code>EchoRequest</code> message.\nRequesting an <code>EchoReply</code> from the receiver (defined in …\nRequesting an <code>EchoReply</code> from the receiver.\nDeprecated use err::ReadError instead or use the specific …\nPayload with it’s type identified by an ether type number\nPayload with it’s type identified by an ether type number\nEther payload without header.\nPayload of an IP packet.\nRepresents an “Ethertype” present in a Ethernet II …\nA slice containing an Ethernet II header.\nEthernet II header.\nA slice containing an ethernet 2 header of a network …\nSlice containing an Ethernet 2 headers &amp; payload.\nFibre Channel [Murali_Rajagopal][RFC6172]\nFIRE [Criag_Partridge]\nFragment Header for IPv6 [RFC8200]\nGateway-to-Gateway [RFC823]\nGMTP [[RXB5]]\nGeneric Routing Encapsulation [RFC2784][Tony_Li]\nHost Identity Protocol [RFC7401]\nHost Monitoring [RFC869][Bob_Hinden]\nIPv6 Hop-by-Hop Option [RFC8200]\nInteractive Agent Transfer Protocol [John_Murphy]\nInternet Control Message [RFC792]\nInter-Domain Policy Routing Protocol [Martha_Steenstrup]\nIDPR Control Message Transport Proto [Martha_Steenstrup]\nInter-Domain Routing Protocol [Sue_Hares]\nIpsilon Flow Management Protocol [Bob_Hinden][November …\nInternet Group Management [RFC1112]\nany private interior gateway (used by Cisco for their …\nIL Transport Protocol [Dave_Presotto]\nIntegrated Net Layer Security  TUBA [K_Robert_Glenn]\nInternet Packet Core Utility [Steven_Blumenthal]\nIP-within-IP Encapsulation Protocol [John_Ioannidis]\nIPLT [[Hollbach]]\nInternet Pluribus Packet Core [Steven_Blumenthal]\nIPv4 encapsulation [RFC2003]\nIPv6 encapsulation [RFC2473]\nDestination Options for IPv6 [RFC8200]\nFragment Header for IPv6 [Steve_Deering]\nIPv6 Hop-by-Hop Option [RFC8200]\nICMP for IPv6 [RFC8200]\nNo Next Header for IPv6 [RFC8200]\nRouting Header for IPv6 [Steve_Deering]\nIPX in IP [CJ_Lee]\nIP Payload Compression Protocol [RFC2393]\nDeprecated use IpAuthHeader instead.\nInternet Reliable Transaction [RFC938] [Trudy_Miller]\nISIS over IPv4 [Tony_Przygienda]\nISO Internet Protocol [Marshall_T_Rose]\nISO Transport Protocol Class 4 [RFC905] [mystery contact]\nEcho Request &amp; Response common parts between ICMPv4 and …\nA slice containing an Icmp4 header &amp; payload.\nPayload part of an ICMP V4 message. Check <code>crate::Icmpv4Type</code>\nPayload part of an ICMP V4 message. Check <code>crate::Icmpv4Type</code>\nA header of an ICMPv4 packet.\nA slice containing an ICMPv4 network package.\nStarting contents of an ICMPv4 packet without the checksum.\nA slice containing an Icmp6 header &amp; payload.\nPayload part of an ICMP V4 message. Check <code>crate::Icmpv6Type</code>\nPayload part of an ICMP V4 message. Check <code>crate::Icmpv6Type</code>\nThe statically sized data at the start of an ICMPv6 packet …\nVariable length data of an ICMPv6 packet.\nA slice containing an ICMPv6 network package.\nDifferent kinds of ICMPv6 messages.\nDeprecated use <code>crate::NetSlice</code> or <code>crate::IpSlice</code> instead. …\nIO error was encountered while reading header or expected …\nError while parsing a IP header.\nPayload with is’s type identified by an ip number (e.g. …\nPayload with is’s type identified by an ip number (e.g. …\nError while parsing a IP authentication header.\nIP Authentication Header (rfc4302)\nA slice containing an IP Authentication Header (rfc4302)\nDeprecated use IpAuthHeader instead.\nDeprecated use IpAuthHeaderSlice instead.\nThe fragment offset is a 13 bit unsigned integer …\nIP Fragment offset present in the IPv4 header and IPv6 …\nDeprecated use <code>crate::NetHeaders</code> instead.\nInternet protocol headers version 4 &amp; 6.\nIdentifiers for the next_header field in ipv6 headers and …\nPayload of an IP packet.\nSlice containing the IP header (v4 or v6), extension …\nThis type has been deprecated please use IpNumber instead.\nIPv4 header &amp; extension headers.\nError while parsing a IPv4 header.\nIPv4 header &amp; extension headers.\nThe ipv4 header &amp; the decoded extension headers.\nThe ipv4 header &amp; the decoded extension headers.\nThe ipv4 header &amp; the decoded extension headers.\nIPv4 header &amp; extension headers.\nThe ipv4 header &amp; the decoded extension headers.\nThe ipv4 header &amp; the decoded extension headers.\n6 bit unsigned integer containing the “Differentiated …\nIPv4 Header DSCP (Differentiated Services Code Point) field\n2 bit unsigned integer containing the “Explicit …\nIPv4 Header ECN (Explicit Congestion Notification) field …\nIPv4 extension headers present after the ip header.\nSlices of the IPv4 extension headers present after the ip …\nIPv4 header with options.\nA slice containing an ipv4 header of a network package.\nLength\nOptions present in an <code>crate::Ipv4Header</code>.\nIPv4 Header “total length” field based on the payload …\nSlice containing the IPv4 headers &amp; payload.\nIPv6 header &amp; extension headers.\nError while parsing a IPv6 header.\nIPv6 header &amp; extension headers.\nThe ipv6 header &amp; the decoded extension headers.\nThe ipv6 header &amp; the decoded extension headers.\nThe ipv6 header &amp; the decoded extension headers.\nIPv6 header &amp; extension headers.\nThe ipv6 header &amp; the decoded extension headers.\nThe ipv6 header &amp; the decoded extension headers.\nEnum containing a slice of a supported ipv6 extension …\nAllows iterating over the IPv6 extension headers present …\nIPv6 extension headers present after the ip header.\nSlice containing the IPv6 extension headers present after …\nError while parsing a IPv6 extension header.\nThe IPv6 “Flow Label” is a 20 bit unsigned integer …\nIPv6 Header Flow Label field present in <code>crate::Ipv6Header</code>.\nIPv6 fragment header.\nSlice containing an IPv6 fragment header.\nIPv6 header according to rfc8200.\nError occurred in the IPv6 layer.\nA slice containing an ipv6 header of a network package.\nIPv6 Header “payload length” field present in an …\nRaw IPv6 extension header (undecoded payload).\nSlice containing an IPv6 extension header without specific …\nDeprecated. Use Ipv6RawExtHeader instead.\nDeprecated. Use Ipv6RawExtHeaderSlice instead.\nIn case a route header is present it is also possible to …\nSlice containing the IPv6 headers &amp; payload.\nKryptolan [Paul Liu]\nLocus Address Resolution Protocol [Brian Horn]\nLayer Two Tunneling Protocol [RFC3931][Bernard_Aboba]\nLeaf-1 [Barry_Boehm]\nLeaf-2 [Barry_Boehm]\nSerialized size of two VLAN headers in bytes/octets.\nSerialized size of an Ethernet2 header in bytes/octets.\nSerialized size of an VLAN header in bytes/octets.\nLength of the serialized header.\nSerialized size of an IPv6 header in bytes/octets.\nSerialized size of an IcmpEchoHeader header in …\nSerialized size of an UDP header in bytes/octets.\nSerialized size of an UDP header in bytes/octets in an <code>u16</code>.\nLaxly identified payload of an IP packet (potentially …\nSlice containing laxly separated IPv4 or IPv6 headers &amp; …\nSlice containing laxly separated IPv4 headers &amp; payload.\nSlice containing laxly separated IPv6 headers &amp; payload.\nSlice containing laxly parsed the network headers &amp; …\nDecoded packet headers (data link layer and lower) with …\nLaxly parsed payload together with an identifier the type …\nPacket slice split into multiple slices containing the …\nError when parsing had to be aborted because of a length …\nSources of length limiting values (e.g. “ipv6 payload …\nA slice containing the link layer header (currently only …\nMANET Protocols [RFC5498]\nThe maximum allowed value for the data offset (it is a 4 …\nThe maximum amount of bytes/octets that can be stored in …\nMaximum length of an IP authentication header in …\nMaximum summed up length of all extension headers in …\nMaximum summed up length of all extension headers in …\nMaximum length of an IPv4 header in bytes/octets.\nMaximum length of the IPv4 options in bytes.\nMaximum summed up length of all extension headers in …\nMaximum length of an raw IPv6 extension header in …\nMaximum summed up length of all extension headers in …\nMaximum number of bytes/octets an Icmpv4Header takes up in …\nMaximum number of bytes/octets an Icmpv6Header takes up in …\nMaximum length of a TCP header in bytes/octets.\nMaximum number of bytes that can be part of an TCP options.\nMaximum length of a Ipv6RawExtHeader the payload\nDeprecated, use <code>Icmpv4Header::MAX_LEN</code> instead.\nDeprecated, use <code>Icmpv6Header::MAX_LEN</code> instead.\nMaximum value of an VLAN id.\nMaximum value of an IP fragmentation offset.\nMaximum value of an IPv6 Flow Label.\nMaximum value of an vlan header PCP.\nMaximum value of an IPv4 header DSCP.\nMaximum value of an IPv4 header ECN.\nMERIT Internodal Protocol [Hans_Werner_Braun]\nMFE Network Services Protocol [Shuttleworth, B., “A …\nMobile Internetworking Control Pro. (deprecated) …\nThe minimum data offset size (size of the tcp header …\nMinimum length of an IP authentication header in …\nMinimum length required for extension header in …\nMinimum length of an IPv4 header in bytes/octets.\nMinimum length required for extension header in …\nMinimum length of an raw IPv6 extension header in …\nMinimum length required for routing extension headers in …\nMinimum number of bytes/octets an Icmpv4Header takes up in …\nMinimum number of bytes an ICMP header needs to have.\nMinimum length of a TCP header in bytes/octets.\nMinimum length of an IPv4 header in bytes/octets as an <code>u16</code>.\nMinimum length of a Ipv6RawExtHeader payload\nDeprecated, use <code>Icmpv4Header::MIN_LEN</code> instead.\nDeprecated, use <code>Icmpv6Header::MIN_LEN</code> instead.\nIP Mobility [Charlie_Perkins]\nMobilityHeader [RFC6275]\n[RFC4023]\nMulticast Transport Protocol [Susie_Armstrong]\nMultiplexing [Cohen, D. and J. Postel, “Multiplexing …\n“Maximum Segment Size” option.\nNBMA Address Resolution Protocol [RFC1735]\nBulk Data Transfer Protocol [RFC969] [David_Clark]\nNSFNET-IGP [Hans_Werner_Braun]\nNetwork Voice Protocol [RFC741][Steve_Casner]\nHeaders on the network layer (e.g. IP, ARP, …).\nSlice containing the network headers &amp; payloads (e.g. …\n“No-Operation” option.\nThere is not enough memory to store all options in the …\nIpv4Ecn with value 0.\nOSPFIGP [RFC1583][RFC2328][RFC5340][John_Moy]\nPGM Reliable Transport Protocol [Tony_Speakman]\nProtocol Independent Multicast [RFC7761][Dino_Farinacci]\nPrivate IP Encapsulation within IP [Bernhard_Petri]\nPNNI over IP [Ross_Callon]\nPacket Radio Measurement [Zaw_Sing_Su]\nPerformance Transparency Protocol [Michael_Welzl]\nPUP\nPacket Video Protocol [Steve_Casner]\nHelper for building packets.\nAn unfinished packet that is build with the packet builder\nDecoded packet headers (data link layer and lower).\nSent if a packet to too big to be forwarded.\nSent if there is a problem with a parameter in a received …\nSent if there is a problem with a parameter in a received …\nPayload together with an identifier the type of content.\nQNX [Michael_Hunter]\nReliable Data Protocol [RFC908] [Bob_Hinden]\nRobust Header Compression [RFC5858]\nReservation Protocol [RFC2205][RFC3209][Bob_Braden]\nRSVP-E2E-IGNORE [RFC3175]\nMIT Remote Virtual Disk Protocol [Michael_Greenwald]\nDeprecated use err::ReadError instead or use the specific …\nRequests data packets be sent on an alternative route …\nRouting Header for IPv6 [RFC8200] [RFC5095]\nSATNET and Backroom EXPAK [Steven_Blumenthal]\nSATNET Monitoring [Steven_Blumenthal]\nSemaphore Communications Sec. Pro. [Howard_Hart]\nSCPS [Robert_Durst]\nStream Control Transmission Protocol [Randall_R_Stewart]\nSource Demand Routing Protocol [Deborah_Estrin]\nSECURE-VMTP [Dave_Cheriton]\nDeprecated use <code>Ethernet2Header::LEN</code> instead.\nDeprecated use <code>Ipv4Header::MIN_LEN</code> instead.\nShim6 Protocol [RFC5533]\nSimple Message Protocol [Leif_Ekblad]\nSitara Networks Protocol [Manickam_R_Sridhar]\nSKIP [Tom_Markson]\nSimple Multicast Protocol (deprecated) [Jon_Crowcroft]…\nSprite RPC Protocol [Welch, B., “The Sprite Remote …\nSecure Packet Shield [Bill_McIntosh]\nSpectraLink Radio Protocol [Mark_Hamilton]\nSSCOPMCE [Kurt_Waber]\nSchedule Transfer Protocol [Jean_Michel_Pittet]\nStream [RFC1190] [RFC1819]\nSUN ND PROTOCOL-Temporary [William_Melohn]\nIP with Encryption (deprecated) [John_Ioannidis]\nIEEE 802.1Q VLAN Tagging Header\nIEEE 802.1Q VLAN Tagging Header\nA slice containing a single vlan header of a network …\nSlice containing a VLAN header &amp; payload.\nLimiting length was the slice length (we don’t know what …\nPacket slice split into multiple slices containing the …\nTCF [Guillermo_A_Loyola]\nTransmission Control [RFC793]\nDeprecated use <code>TcpHeader::MAX_DATA_OFFSET</code> instead.\nDeprecated use <code>TcpHeader::MIN_DATA_OFFSET</code> instead.\nDeprecated use <code>TcpHeader::MIN_LEN</code> instead.\nDeprecated please use tcp_option::KIND_END instead.\nDeprecated please use tcp_option::KIND_MAXIMUM_SEGMENT_SIZE…\nDeprecated please use tcp_option::KIND_NOOP instead.\nDeprecated please use tcp_option::KIND_SELECTIVE_ACK …\nDeprecated please use …\nDeprecated please use tcp_option::KIND_TIMESTAMP instead.\nDeprecated please use tcp_option::KIND_WINDOW_SCALE …\nThird Party Connect Protocol [Stuart_A_Friedberg]\nTransport Layer Security Protocol using Kryptonet key …\nTP++ Transport Protocol [Dirk_Fromhein]\nIpv4Ecn with value 0.\nTrunk-1 [Barry_Boehm]\nTrunk-2 [Barry_Boehm]\nTransaction Transport Protocol or Internet Protocol …\nIpv4Ecn with value 0.\nError while parsing a TCP extension header.\nA slice containing a TCP header.\nTCP payload.\nTCP payload.\nTCP header according to rfc 793.\nError occurred while decoding a TCP header.\nA slice containing an tcp header of a network package.\nDifferent kinds of options that can be present in the …\nErrors that can occour while reading the options of a TCP …\nErrors that can occour when setting the options of a tcp …\nOptions present in a TCP header.\nAllows iterating over the options after a TCP header.\nPayload length used when calculating the checksum of a …\nPayload length used when calculating the checksum of a …\nSlice containing the TCP header &amp; payload.\nGenerated when a datagram had to be discarded due to the …\nGenerated when a datagram had to be discarded due to the …\nTimestamp &amp; echo (first number is the sender timestamp, …\nAnwser to a <code>TimestampRequest</code> message.\nTimestamp is used for time synchronization.\nThe possible headers on the transport layer\nUser Datagram [RFC768][Jon_Postel]\nUDPLite [RFC3828]\nUTI [Peter_Lothberg]\nA slice containing an UDP header &amp; payload.\nUDP payload.\nUDP payload.\nUdp header according to rfc768.\nError occurred while decoding an UDP header.\nA slice containing an udp header of a network package. …\nPayload length used when calculating the checksum of a …\nPayload length used when calculating the checksum of a …\nSlice containing the UDP headers &amp; payload.\nReturned if an option id was read, but there was not …\nReturned if the option as an unexpected size argument …\nIn case of an unknown ICMP type and code combination is …\nIn case of an unknown icmp type is received the header …\nReturned if an unknown tcp header option is encountered.\nVINES [Brian Horn]\nVISA Protocol [Gene_Tsudik]\nAll ether types that identify a vlan header.\nVMTP [Dave_Cheriton]\nVirtual Router Redundancy Protocol [RFC5798]\nIEEE 802.1Q VLAN Tagging Header (can be single or double …\n12 bit unsigned integer containing the “VLAN identifier…\nVLAN identifier field present in a <code>crate::SingleVlanHeader</code>.\n3 bit unsigned integer containing the “Priority Code …\nVLAN PCP (Priority Code Point) field in a …\nA slice containing a single or double vlan header.\nWIDEBAND EXPAK [Steven_Blumenthal]\nWIDEBAND Monitoring [Steven_Blumenthal]\nWrapped Encapsulating Security Payload [RFC5840]\nWang Span Network [Victor Dafoulas]\nCross Net Debugger [Haverty, J., “XNET Formats for …\nXEROX NS IDP\nXTP [Greg_Chesson]\nVlanId with value 0.\nVlanPcp with value 0.\nIpFragOffset with value 0.\nIpv4Dscp with value 0.\nIpv4Ecn with value 0.\nIpv6FlowLabel with value 0.\nSets the ack flag and the acknowledgment_number.\nReads the ack flag (acknowledgment field significant).\nReads the ack flag (acknowledgment field significant).\nAcknowledgment field significant\nReads the acknowledgment number.\nReads the acknowledgment number in the TCP header.\nIf the ACK control bit is set this field contains the …\nReturns a mutable slice containing the data of the options.\nMutable slice containing the options.\nReturns the slice containing the data of the options.\nSlice containing the options.\nReturns the bytes from position 4 till and including the …\nReturns the bytes from position 4 till and including the …\nCalculate the ICMP checksum value.\nCalculates the checksum of the ICMPv6 header.\nCalculates the upd header checksum based on a ipv4 header …\nCalculates the TCP header checksum based on a ipv4 header …\nCalculates the checksum for the current header in ipv4 …\nCalculates the upd header checksum based on a ipv4 header.\nCalculates the checksum for the current header in ipv4 …\nCalculates the checksum for the current header in ipv4 …\nCalculates the upd header checksum based on a ipv4 header.\nCalculates the upd header checksum based on a ipv6 header …\nCalculates the TCP header checksum based on a ipv6 header …\nCalculates the checksum for the current header in ipv6 …\nCalculates the checksum of the current udp header given an …\nCalculates the checksum for the current header in ipv6 …\nCalculates the checksum for the current header in ipv6 …\nCalculates the checksum of the current udp header given an …\nCalculate header checksum of the current ipv4 header.\nHelpers for calculating checksums.\nReturns “checksum” value in the ICMPv4 header.\nReturns “checksum” value in the ICMPv6 header.\nChecksum (16 bit one’s complement) of the pseudo ip …\nChecksum (16 bit one’s complement) of the pseudo ip …\nReads the “checksum” from the slice.\nReads the “checksum” from the slice.\nChecksum in the ICMP header.\nChecksum in the ICMPv6 header.\nChecksum (16 bit one’s complement) of the pseudo ip …\nThe checksum of the packet. The checksum is calculated …\nReturns “code” value in the ICMPv4 header.\nReturns “code” value in the ICMPv6 header.\nReturns the code value (second byte of the ICMPv6 header) …\nSet cwr flag (Congestion Window Reduced)\nReads the cwr flag (Congestion Window Reduced).\nReads the cwr flag (Congestion Window Reduced).\nCongestion Window Reduced (CWR) flag\nThe number of 32 bit words in the TCP Header &amp; TCP header …\nRead the number of 32 bit words in the TCP Header.\nThe number of 32 bit words in the TCP Header &amp; TCP header …\nRead the number of 32 bit words in the TCP Header.\nRead the “differentiated_services_code_point” from the …\nRead the destination MAC address\nRead the destination MAC address\nReturns a slice containing the ipv4 source address.\nReturns a slice containing the IPv6 destination address.\nDestination MAC Address\nIPv4 destination address\nIPv6 destination address\nReturn the destination address as an std::net::IpAddr …\nReturn the ipv4 destination address as an …\nReturn the ipv6 destination address as an …\nReturn the ipv6 destination address as an …\nReturn the destination address as an std::net::IpAddr …\nRead the destination port number.\nRead the destination port number in the TCP header.\nReads the “udp destination port” from the slice.\nReads the “udp destination port” in the UDP header.\nThe destination port number.\nDestination port of the packet.\nRead the “dont fragment” flag from the slice.\nIf set the packet is not allowed to fragmented.\nAdds two vlan tagging header with the given vlan …\nRead the “drop_eligible_indicator” flag from the …\nRead the “drop_eligible_indicator” flag of the VLAN …\nIndicate that the frame may be dropped under the presence …\nDifferentiated Services Code Point\nSets ece flag (ECN-Echo, RFC 3168)\nRead the ECN-Echo flag (RFC 3168).\nRead the ECN-Echo flag (RFC 3168).\nECN-Echo (RFC 3168)\nRead the “explicit_congestion_notification” from the …\nExplicit Congestion Notification\nReturns an iterator that allows to iterate through the …\nModule containing error types that can be triggered.\nReturns the last ether payload of the packet (if one is …\nReturns the last ether payload of the packet (if one is …\nConstants for the ethertype values for easy importing …\nRead the ether_type field of the header indicating the …\nRead the ether_type field of the header indicating the …\nRead the “Tag protocol identifier” field from the …\nRead the “Tag protocol identifier” field from the VLAN …\nIdentifying content of the payload.\nProtocol present after the ethernet2 header.\n“Tag protocol identifier”: Type id of content after …\nStart an packet with an ethernetII header.\nReturns a slice containing the IPv4 extension headers.\nReturns a slice containing the IPv6 extension headers.\nReturns a slice containing the IPv4 extension headers.\nReturns a slice containing the IPv6 extension headers.\nReturns the frame check sequence if present.\nSet fin flag (No more data from sender)\nRead the fin flag (no more data from sender).\nRead the fin flag (no more data from sender).\nNo more data from sender\nReturns the ip protocol number of the first header in the …\nIf the ICMP type has a fixed size returns the number of …\nIf the ICMP type has a fixed size returns the number of …\nIf the ICMP type has a fixed size returns the number of …\nIf the ICMP type has a fixed size returns the number of …\nRead the “flow label” field from the slice.\nIf non 0 serves as a hint to router and switches with …\nFragment offset\nIn case this message contains parts of a fragmented packet …\nOffset of the current IP payload relative to the start of …\nTrue if the payload is not complete and has been …\nTrue if the payload is not complete and has been …\nRead the “fragment_offset” field from the slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRead an Ethernet2Header from a static sized byte array.\nRead an SingleVlanHeader from a static sized byte array.\nDecodes the seq + id from the on the wire format.\nRead an UdpHeader from a static sized byte array.\nSeparates a network packet into different headers using …\nSeparates a network packet slice into different slices …\nTries to decode a network packet into different headers …\nSeparates a network packet slice into different slices …\nSeparates a network packet into different headers from the …\nSeparates a network packet slice into different slices …\nSeparates a network packet slice into different slices …\nDecodes a network packet into different headers from a …\nSeparates a network packet slice into different headers …\nSeparates a network packet slice into different slices …\nSeparates a network packet slice into different slices …\nTries to decode an ip packet and its transport headers.\nRead an IPv4 header &amp; extension headers from a slice and …\nReads an IPv4 header &amp; its extensions headers as far as is …\nRead an IPv6 header &amp; extension headers from a slice and …\nReads an IPv6 header &amp; its extensions headers as far as is …\nRead an DoubleVlanHeader from a slice and return the …\nCreates a double header slice from a slice.\nTry creating a <code>DoubleVlanSlice</code> from a slice containing the …\nRead an Ethernet2Header from a slice and return the header …\nCreates a ethernet slice from an other slice.\nRead an SingleVlanHeader from a slice and return the …\nCreates a vlan header slice from a slice.\nTry creating a <code>SingleVlanSlice</code> from a slice containing the …\nRead an  authentication header from a slice and return the …\nCreates a ip authentication header slice from a slice.\nRead an <code>IpHeaders</code> from a slice and return the headers &amp; …\nSeparates and validates IP headers (including extension …\nRead all known ipv4 extensions and return an <code>Ipv4Extensions</code>…\nRead all known ipv4 extensions and return an …\nRead an Ipv4Header from a slice and return the header &amp; …\nCreates a slice containing an ipv4 header (including …\nSeparates and validates IPv4 headers (including extension …\nReads as many extension headers as possible from the slice.\nCollects all ipv6 extension headers in a slice &amp; checks if …\nRead an Ipv6FragmentHeader from a slice and return the …\nCreates a hop by hop header slice from a slice.\nRead an Ipv6Header from a slice and return the header &amp; …\nCreates a slice containing an ipv6 header (without header …\nRead an Ipv6ExtensionHeader from a slice and return the …\nCreates a generic ipv6 extension header slice from a slice.\nSeparates and validates IPv6 headers (including extension …\nSeparates IP headers (include extension headers) &amp; the IP …\nSeparates and validates IPv4 headers (including extension …\nSeperate an IPv6 header (+ extensions) &amp; the payload from …\nReads an icmp4 header from a slice directly and returns a …\nCreates a slice containing an ICMPv4 packet.\nReads an icmp6 header from a slice directly and returns a …\nCreates a slice containing an ICMPv6 packet.\nReads a tcp header from a slice\nCreates a slice containing an tcp header.\nCreates an options iterator from a slice containing …\nTry creating a <code>TcpSlice</code> from a slice containing the TCP …\nReads a udp header from a slice directly and returns a …\nCreates a slice containing an udp header.\nDecode length from UDP header and restrict slice to the …\nReads an <code>IpHeaders</code> as far as possible without encountering …\nCollects all known ipv4 extension headers in a slice until …\nCollects all ipv4 extension headers in a slice until an …\nReads as many extension headers as possible from the slice …\nCollects all ipv6 extension headers in a slice until an …\nSeperate an IPv6 header (+ extensions) &amp; the payload from …\nTry decoding length from UDP header and restrict slice to …\nCreates a ip authentication header slice from a slice …\nCreates a hop by hop header slice from a slice (assumes …\nCreates a raw ipv6 extension header slice from a slice …\nTry creating a <code>Ethernet2Slice</code> from a slice containing the …\nTry creating a <code>Ethernet2Slice</code> from a slice containing the …\nReturns a slice containing the IPv4 header.\nReturns a slice containing the IPv6 header.\nReturns a slice containing the IPv4 header.\nReturns a slice containing the IPv6 header.\nDecode the header values into an <code>Icmpv4Header</code> struct.\nDecode the header fields and copy the results to a …\nRead the “header checksum” field from the slice.\nLength of the serialized headers in bytes.\nLength of the VLAN header in bytes (equal to …\nLength of the serialized header in bytes.\nLength of the Ethernet 2 header in bytes (equal to …\nLength of the serialized header in bytes.\nLength of the VLAN header in bytes (equal to …\nLength of the serialized header(s) in bytes.\nLength of the header in bytes.\nReturns the size when the ip header &amp; extensions are …\nLength of the all present headers in bytes.\nLength of the header (includes options) in bytes.\nLength of the all present headers in bytes.\nLength of the header in bytes.\nLength of the serialized header in bytes.\nReturns the length of the IPv6 header in bytes (same as …\nLength of the header in bytes.\nReturn the length of the headers in bytes.\nReturns the size when the header &amp; extension headers are …\nLength in bytes/octets of this header type.\nNumber of bytes/octets that will be converted into a …\nReturns the length in bytes/octets of the header of this …\nSerialized length of the header in bytes/octets.\nNumber of bytes/octets that will be converted into a …\nSerialized length of the header in bytes/octets.\nReturns the length of the header including the options.\nLength of the TCP header (including TCP options).\nReturns the size of the transport header (in case of UDP …\nLength of the serialized header in bytes.\nLength of the UDP header (equal to <code>crate::UdpHeader::LEN</code>).\nReturns the length of the header including the options.\nLength of the serialized header in bytes in an <code>u16</code>.\nLength of the UDP header in an <code>u16</code> (equal to …\nSlice containing the Ethernet 2 header.\nSlice containing the Ethernet 2 header.\nReturns the slice containing the TCP header (including …\nReturn the slice containing the UDP header.\nReturns true if the given header type ip number can be …\nReturns true if the given header type ip number can be …\nRead the “hop limit” field from the slice. The hop …\nThe number of hops the packet can take before it is …\nDecode the header values (excluding the checksum) into an …\nDecode the header values (excluding the checksum) into an …\nType &amp; type specific values &amp; code.\nType &amp; type specific values &amp; code.\nModule containing ICMPv4 related types and constants.\nAdds an ICMPv4 header of the given <code>Icmpv4Type</code> to the …\nReturns Result::Some containing the ICMPv4 header if self …\nAdds an ICMPv4 echo reply packet.\nAdds an ICMPv4 echo request packet.\nAdds an ICMPv4 header based on raw numbers.\nModule containing ICMPv6 related types and constants\nAdds an ICMPv6 header of the given <code>Icmpv6Type</code> to the …\nReturns Result::Some containing the ICMPv6 header if self …\nAdds an ICMPv6 echo request packet.\nAdds an ICMPv6 echo reply packet.\nAdds an ICMPv6 header based on raw values.\nAn identifier to aid in matching Echo Replies to Echo …\nRead the “identification” field from the slice.\nIdentifcation value generated by the source\nNumber used to identify packets that contain an originally …\nIdentifcation value generated by the source.\nLength of the header in multiples of 4 bytes (often also …\nRead the “ip header length” (length of the ipv4 header …\nTrue if the length field in the IP header indicates more …\nReturns a slice with the inner vlan header.\nInner VLAN header &amp; payload.\nThe inner vlan tagging header\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarts a packet with an arbitrary IP header (length, …\nAdd an ip header (length, protocol/next_header &amp; checksum …\nAdd an IP header (length, protocol/next_header &amp; checksum …\nConstants for the ip protocol numbers for easy importing …\nIdentifying content of the payload.\nIdentifying content of the payload.\nReturn the IP payload after the the IP header and the IP …\nReturn the IP payload after the the IP header and the IP …\nReturns a reference to ip payload if the net slice contains\nReturns a reference to ip payload if the net slice contains\nStarts a packet with an IPv4 header.\nAdd an IPv4 header\nAdd an IPv4 header\nReturns references to the IPv4 header &amp; extensions if the …\nReturns a reference to the <code>Ipv4Slice</code> if <code>self</code> is a …\nReturns a reference to the <code>Ipv4Slice</code> if <code>self</code> is a …\nReturns references to the IPv4 header &amp; extensions if the …\nStart a packet with an IPv6 header.\nAdd an IPv6 header\nAdd an IPv6 header\nReturns references to the IPv6 header &amp; extensions if the …\nReturns a reference to the <code>Ipv6Slice</code> if <code>self</code> is a …\nReturns a reference to the <code>Ipv6Slice</code> if <code>self</code> is a …\nReturns references to the IPv6 header &amp; extensions if the …\nReturns if the checksum in the slice is correct.\nReturns true if no IPv4 extension header is present (all …\nReturns true if no IPv4 extension header is present (all …\nReturns if the length of the options is zero.\nReturns true if no IPv6 extension header is present (all …\nReturns true if no IPv6 extension header is present (slice …\nReturns true if the options contain no elements.\nReturns true if the payload is fragmented based on the …\nReturns true if the payload is fragmented.\nReturns true if the payload is fragmented.\nReturns true if the payload is fragmented.\nReturns true if a fragmentation header is present in the …\nReturns true if a fragmentation header is present in the …\nChecks if the fragment header actually fragments the …\nChecks if the fragment header actually fragments the …\nReturns true if the payload is fragmented.\nReturns true if the given number is the internet number of …\nReturns true if the payload is flagged as being fragmented.\nReturns true if the payload is flagged as being fragmented.\nReturns true if the payload is flagged as being fragmented.\nReturns true if the payload is flagged as being fragmented.\nReturns true if the given ip protocol number is a …\nReturns the “keyword” string if known. Usually this is …\nReturns the length of the options in bytes.\nNumber of bytes in the buffer.\nLength field that was used to determine the length of the …\nLength field that was used to determine the length of the …\nReturns the length of the options in bytes.\nNumber of bytes in the buffer as an unsigned 8 bit integer.\nReads the “length” from the slice.\nReads the “length” field in the UDP header.\nLength of the packet (includes the udp header length of 8 …\nEthernet II header if present.\nEthernet II header if present.\nEthernet II header if present.\nEthernet II header if present.\nReturns the maximum payload size based on the current …\nRead the “more fragments” flag from the slice.\nTrue if more fragment packets will follow. False if this …\nIndicates that the packet contains part of an fragmented …\nTrue if more fragment packets will follow. False if this …\nReturns Result::Some containing the ICMPv4 header if self …\nReturns Result::Some containing the ICMPv6 header if self …\nReturns Result::Some containing a mutable reference to the …\nReturns Result::Some containing the udp header if self has …\nIPv4 or IPv6 header and IP extension headers if present.\nIPv4 or IPv6 header, IP extension headers &amp; payload if …\nIPv4 or IPv6 header and IP extension headers if present.\nIPv4 or IPv6 header, IP extension headers &amp; payload if …\nCreate a new authentication header with the given …\nConstructs an Ipv4Header with standard values for non …\nSetup an empty options array.\nCreate a new fragmentation header with the given …\nConstructs an <code>Icmpv4Header</code> using the given type and the …\nSetups a new header with the checksum being set to 0.\nCreates a TcpHeader with the given values and the rest …\nConstructs a new empty TcpOptions.\nCreates an generic IPv6 extension header with the given …\nCreates an <code>VlanId</code> WITHOUT checking that the value is …\nCreates an <code>VlanPcp</code> without checking that the value is …\nCreates an <code>IpFragOffset</code> without checking that the value is …\nCreates an <code>Ipv4Dscp</code> without checking that the value is …\nCreates an <code>Ipv4Ecn</code> without checking that the value is …\nCreates an <code>Ipv6FlowLabel</code> without checking that the value …\nReturns the ether type of the next header after the vlan …\nReturns the IP protocol number of the next header or …\nReturns the last next header number following the ip header\nReturn next header based on the extension headers and the …\nReturn next header based on the extension headers and the …\nReturns the IP protocol number of the next header.\nRead the “next header” field from the slice.\nReturns the IP protocol number of the next header or …\nIP protocol number specifying the next header or transport …\nIP protocol number specifying the next header or transport …\nIP protocol number specifying the next header or transport …\nIP protocol number specifying the next header or transport …\nIP protocol number specifying the next header or transport …\nIP protocol number specifying the next header or transport …\nIP protocol number specifying the next header or transport …\nSet ns flag (ECN-nonce - concealment protection; …\nECN-nonce - concealment protection (experimental: see RFC …\nECN-nonce - concealment protection (experimental: see RFC …\nECN-nonce - concealment protection (experimental: see RFC …\nSet the tcp options of the header.\nReturns a slice to the options part of the header (empty …\nReturns a slice containing the ipv4 header options (empty …\nReturns a slice containing the options of the header (size …\nOptions of the header\nOptions of the header\nOptions in the header (in raw).\nOptions in the TCP header.\nReturns an iterator that allows to iterate through all …\nReturns an iterator that allows to iterate through all …\nReturns an iterator that allows to iterate through all …\nReturns the options size in bytes based on the currently …\nSet the tcp options of the header (setting the bytes …\nReturns a slice with the outer vlan header\nOuter VLAN header &amp; payload (includes header of inner vlan …\nThe outer vlan tagging header\nReturns the slice containing the payload &amp; ether type …\nReturns the slice containing the Ethernet II payload &amp; …\nReturns the link layer payload (slice + ether type number).\nReturns the slice containing the VLAN payload &amp; ether type …\nReturns a slice containing the data after the IP header …\nReturns a slice containing the data after the IPv4 header …\nReturn a slice containing the current payload. This does …\nReturns a slice containing the payload data of the header.\nReturns a slice containing the data after the IPv6 header …\nReturns a slice containing the data after the IP header …\nReturns a slice containing the data after the IPv4 header …\nReturns a slice containing the data after the IPv6 header …\nReturns a slice to the bytes not covered by <code>.header()</code>.\nReturns a slice to the bytes not covered by <code>.header()</code>.\nReturns the slice containing the TCP payload.\nReturns the slice containing the UDP payload.\nPayload\nPayload\nPayload\nPayload of the last parsed layer.\nPayload of the last parsed layer.\nIf the slice in the <code>payload</code> field contains an ethernet …\nReturns the ip number the type of payload of the IP packet.\nReturns the ip number the type of payload of the IPv4 …\nReturns the ip number the type of payload of the IP packet.\nReturns the ip number the type of payload of the IPv4 …\nDetermine the payload length based on the ihl &amp; …\nDetermine the payload length based on the ihl &amp; …\nValue that was used to determine the length of the payload.\nRead the “payload length” field from  the slice. The …\nThe length of the payload and extension headers in bytes …\nReturns the slice containing the payload after both VLAN …\nReturns the slice containing the Ethernet II payload.\nReturns the slice containing the VLAN payload.\nA 3 bit number which refers to the IEEE 802.1p class of …\nRead the “priority_code_point” field from the slice. …\nRead the “priority_code_point” field of the VLAN …\nRead the “protocol” field from the slice.\nIP protocol number specifying the next header or transport …\nReturns the “protocol” string if known. Usually this …\nSets the psh flag (push function)\nReads the psh flag (push function).\nReads the psh flag (push function).\nPush Function\nReturns a slice the raw icv value.\nReturn a slice with the raw integrity check value\nRead a double tagging header from the given source\nReads an Ethernet-II header from the current position of …\nRead a IEEE 802.1Q VLAN tagging header\nRead an authentication header from the current reader …\nReads an IP (v4 or v6) header from the current position …\nReads the known ipv4 extension headers from the reader and …\nReads an IPv4 header from the current position (requires …\nReads as many extension headers as possible from the …\nRead an fragment header from the current reader position.\nReads an IPv6 header from the current position.\nRead an fragment header from the current reader position.\nReads an ICMPv4 header from the given reader.\nRead a ICMPv6 header from the given reader\nRead a tcp header from the current position\nTries to read an udp header from the current position.\nRead an DoubleVlanHeader from a slice and return the …\nDeprecated use <code>Ethernet2Header::from_slice</code> instead.\nRead an SingleVlanHeader from a slice and return the …\nRenamed to <code>IpHeaders::from_slice</code>\nRenamed to <code>Ipv4Header::from_slice</code>\nRenamed to <code>Ipv6Header::from_slice</code>\nRenamed to <code>TcpHeader::from_slice</code>\nReads a udp header from a slice directly and returns a …\nRead an authentication header from the current reader …\nReads the known ipv4 extension headers from a length …\nReads as many extension headers as possible from the …\nRead an fragment header from the current reader position.\nRead an fragment header from the current limited reader …\nReads an IPv4 header assuming the version &amp; ihl field have …\nReads an IPv6 header assuming the version &amp; flow_label …\nReturns the non processed part of the options slice.\nSets the rst flag (reset the connection)\nReads the rst flag (reset the connection).\nReads the rst flag (reset the connection).\nReset the connection\nA sequence number to aid in matching Echo Replies to Echo …\nThis unsigned 32-bit field contains a counter value that …\nRead the sequence number of the first data octet in this …\nRead the sequence number in the TCP header.\nThis unsigned 32-bit field contains a counter value that …\nThis unsigned 32-bit field contains a counter value that …\nThis unsigned 32-bit field contains a counter value that …\nThe sequence number of the first data octet in this …\nSets all the next_header fields in the ipv4 &amp; ipv6 header …\nSets all the next_header fields of the headers based on …\nSets all the next_header fields of the headers based on …\nSets the options &amp; header_length based on the provided …\nSets the options (overwrites the current options) or …\nSets the options to the data given.\nSets the payload (content of the header after the …\nTries to set the length field in the ip header given the …\nTries setting the <code>Ipv4Header::total_len</code> field given the …\nSets the field total_length based on the size of the …\nSets the icv value to the given raw value. The length of …\nAdds a vlan tagging header with the given vlan identifier\nReturns the size of the packet when it is serialized\nReturns the size of the packet when it is serialized\nReturns the size of the packet when it is serialized\nReturns the size of the packet when it is serialized\nReturns the size of the packet when it is serialized\nSkips all ipv6 header extensions and returns the next ip …\nTakes a slice &amp; ip protocol number (identifying the first …\nSkips the ipv6 header extension and returns the next ip …\nTakes a slice and skips an ipv6 header extensions and …\nReturns the slice containing the double vlan header\nReturns the slice containing the VLAN header and payload.\nReturns the slice containing the ethernet 2 header\nReturns the slice containing the ethernet 2 header payload …\nReturns the slice containing the single vlan header\nReturns the slice containing the VLAN header and payload.\nReturns the slice containing the authentication header.\nReturns the slice containing the ipv4 header\nSlice containing the ipv6 extension headers.\nReturns the slice containing the ipv6 fragment header.\nReturns the slice containing the ipv6 header\nReturns the slice containing the ipv6 extension header\nReturns the slice containing the ICMPv4 packet.\nReturns the slice containing the ICMPv6 packet.\nReturns the slice containing the tcp header\nReturns the slice containing the TCP header and payload.\nReturns the slice containing the udp header\nReturn the slice containing the UDP header &amp; payload.\nRead the source MAC address\nRead the source MAC address\nReturns a slice containing the ipv4 source address.\nReturns a slice containing the IPv6 source address.\nSource MAC Address\nIPv4 source address\nIPv6 source address\nReturn the source address as an std::net::Ipvddr (requires …\nReturn the ipv4 source address as an std::net::Ipv4Addr\nReturn the ipv6 source address as an std::net::Ipv6Addr\nReturn the ipv6 source address as an std::net::Ipv6Addr\nReturn the source address as an std::net::Ipvddr (requires …\nRead the source port number.\nRead the destination port number in the TCP header.\nReads the “udp source port” from the slice.\nReads the “udp source port” in the UDP header.\nThe source port number.\nSource port of the packet (optional).\nRead the security parameters index from the slice\nSecurity Parameters Index\nSecurity Parameters Index\nSecurity Parameters Index\nError that stopped the parsing and the layer on which the …\nError that stopped the parsing and the layer on which the …\nSet the syn flag (synchronize sequence numbers)\nReads the syn flag (synchronize sequence numbers).\nReads the syn flag (synchronize sequence numbers).\nSynchronize sequence numbers\nAdds a simple TCP header.\nReturns Result::Some containing the tcp header if self has …\nAdds a more complicated TCP header.\nModule containing the constants for tcp options (id number …\nNumber of hops the packet is allowed to take before it …\nReturns the serialized form of the headers or an value …\nReturns the serialized form of the header as a statically …\nReturns the serialized form of the header or an value …\nReturns the serialized header.\nReturns the serialized header (note that this method does …\nReturns the serialized form of the header as a statically …\nReturns the serialized form of the header as a statically …\nReturns the serialized header.\nReturn the seq + id encoded to the on the wire format.\nConverts the header to the on the wire bytes.\nReturns the header on the wire bytes.\nReturns the serialized header.\nReturns the serialized form of the header as a statically …\nDecode all the fields and copy the results to a …\nDecode all the fields and copy the results to a …\nDecode all the fields and copy the results to a …\nDecode all the fields and copy the results to a …\nConvert the link slice to a header (currently just the …\nDecode all the fields and copy the results to a …\nDecode all the fields and copy the results to a …\nDecode all the fields and copy the results to a VlanHeader …\nDecode some of the fields and copy the results to a …\nConvert the slices into actual headers.\nDecode all the fields and copy the results to a Ipv4Header …\nDecode some of the fields and copy the results to a …\nDecode all the fields and copy the results to a Ipv6Header …\nConvert the slice to an Ipv6RawExtHeader.\nCreates a header with the correct checksum.\nDecode all the fields and copy the results to a TcpHeader …\nDecode all the fields and copy the results to a …\nDecode all the fields and copy the results to a UdpHeader …\nDecode all the fields of the UDP header and copy the …\nRead the “total length” from the slice (total length …\nTotal length of the IPv4 header (including extension …\nRead the “traffic class” field from the slice.\nTCP or UDP header if present.\nTCP or UDP header &amp; payload if present.\nTCP or UDP header if present.\nTCP or UDP header &amp; payload if present.\nTries to convert <code>crate::TcpOptionElement</code> into serialized …\nTries to convert an <code>u8</code> slice into <code>TcpOptions</code>.\nTries to create an <code>VlanId</code> and checks that the passed value …\nTries to create an <code>VlanPcp</code> and checks that the passed value\nTries to create an <code>IpFragOffset</code> and checks that the passed …\nTries to create an <code>Ipv4Dscp</code> and checks that the passed …\nTries to create an <code>Ipv4Ecn</code> and checks that the passed value\nTries to create an <code>Ipv6FlowLabel</code> and checks that the …\nRead the “time_to_live” field from the slice.\nReturns “type” value in the ICMPv4 header.\nReturns “type” value in the ICMPv6 header.\nReturns the type value (first byte of the ICMPv6 header) …\nAdds an UDP header.\nReturns Result::Some containing the udp header if self has …\nCalculates &amp; updates the checksum in the header.\nUpdates the checksum of the header.\nCalculates the checksum for the transport header &amp; sets it …\nCalculates the checksum for the transport header &amp; sets it …\nSet the urg flag &amp; the urgent pointer field.\nReads the urg flag (Urgent Pointer field significant).\nReads the urg flag (Urgent Pointer field significant).\nUrgent Pointer field significant\nThis field communicates the current value of the urgent …\nThis field communicates the current value of the urgent …\nThis field communicates the current value of the urgent …\nReturns the underlying unsigned 12 bit value as an <code>u16</code> …\nReturns the underlying unsigned 3 bit value as an <code>u8</code> value.\nReturns the underlying unsigned 13 bit value as an <code>u16</code> …\nReturns the underlying unsigned 6 bit value as an <code>u8</code> value.\nReturns the underlying unsigned 2 bit value as an <code>u8</code> value.\nReturns the underlying unsigned 20 bit value as an <code>u32</code> …\nRead the “version” field of the IPv4 header (should be …\nRead the “version” field from the slice (should be 6).\nAdds a vlan tagging header with the given vlan identifier\nSingle or double vlan headers if present.\nSingle or double vlan headers if present.\nSingle or double vlan headers if present.\nSingle or double vlan headers if present.\n12 bits vland identifier.\nReads the 12 bits “vland identifier” field from the …\nReads the 12 bits “vland identifier” field from the …\nThe number of data octets beginning with the one indicated …\nThe number of data octets beginning with the one indicated …\nThe number of data octets beginning with the one indicated …\nCreates a <code>Icmpv4Header</code> with a checksum calculated based on …\nCreates a <code>Icmpv6Header</code> with a checksum calculated based on …\nCalculate an udp header given an ipv4 header and the …\nCalculate an udp header given an ipv6 header and the …\nReturns an udp header for the given parameters\nWrite all the headers and the payload.\nWrite all the headers and the payload.\nWrite all the headers and the payload.\nWrite all the headers and the payload.\nWrite all the headers and the payload with the given ip …\nWrite the double IEEE 802.1Q VLAN tagging header\nWrites a given Ethernet-II header to the current position …\nWrite the IEEE 802.1Q VLAN tagging header\nWrite the IEEE 802.1Q VLAN single or double tagging header\nWrites the given authentication header to the current …\nWrites an IP (v4 or v6) header to the current position …\nWrite the extensions to the writer.\nWrites a given IPv4 header to the current position (this …\nWrites the given headers to a writer based on the order …\nWrites a given IPv6 fragment header to the current …\nWrites a given IPv6 header to the current position.\nWrites a given IPv6 extension header to the current …\nWrite the ICMPv4 header to the given writer.\nWrite the ICMPv6 header to the given writer.\nWrite the tcp header to a stream (does NOT calculate the …\nWrite the transport header to the given writer.\nWrite the udp header without recalculating the checksum or …\nWrites a given IPv4 header to the current position (this …\nSerialize the header to a given slice. Returns the unused …\nBytes located at th 5th, 6th, 7th and 8th position of the …\nICMP code (present in the 2nd byte of the ICMP packet).\nICMP type (present in the first byte of the ICMP packet).\nBytes located at th 5th, 6th, 7th and 8th position of the …\nICMPv6 code (present in the 2nd byte of the ICMPv6 packet).\nThe Maximum Transmission Unit of the next-hop link.\nICMPv6 type (present in the first byte of the ICMPv6 …\nTrue if the payload has been cut off.\nTrue if the payload has been cut off.\nTrue if the payload has been cut off.\nHelper for calculating the sum of all 16 bit words …\nAdd a 16 bytes.\nAdd a 2 byte word.\nAdd a 4 byte word.\nAdd a 8 byte word.\nAdd the given slice to the checksum. In case the slice has …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConverts summed up words from an u32 to an u16 ones …\nConverts summed up words from an u32 to an u16 ones …\nHelper functions for calculating a 16 bit checksum using a …\nHelper functions for calculating a 16 bit checksum using a …\nAdd a 2 byte word.\nAdd a 4 byte word.\nAdd the given slice to the checksum. In case the slice has …\nConverts summed up words from an u32 to an u16 which can …\nConverts summed up words from an u32 to an u16 with 0 …\nAdd a 2 byte word.\nAdd a 4 byte word.\nAdd a 8 byte word.\nAdd the given slice to the checksum. In case the slice has …\nConverts summed up words from an u64 to an u16 which can …\nConverts summed up words from an u64 to an u16 with 0 …\nError while parsing a double vlan header.\nError while parsing a double vlan header.\nPayload identified by an ether type number (e.g. after an …\nError occurred in the ethernet 2 header.\nType aggregating errors that can be caused by decoding …\nError occurred while parsing an ICMP packet.\nError occurred while parsing an ICMP timestamp packet.\nError occurred while parsing an ICMP timestamp reply …\nError occurred while parsing an ICMPv6 packet.\nVariable length data of an ICMPv6 packet.\nIO error was encountered while reading header or expected …\nError while parsing a IP header.\nError while parsing a IP header.\nError while parsing a IP authentication header.\nError while parsing a IP authentication header.\nError occurred in the IP Authentication header.\nIP Fragment offset present in the IPv4 header and IPv6 …\nError occurred when decoding an IP header (v4 or v6).\nError while parsing a IPv4 header.\nError while parsing a IPv4 header.\nIPv4 Header DSCP (Differentiated Services Code Point) field\nIPv4 Header ECN (Explicit Congestion Notification) field …\nError occurred in the IPv4 layer.\nError occurred verifying the total length of an IPv4 …\nIPv4 Header “total length” field based on the payload …\nError while parsing a IPv6 header.\nError while parsing a IPv6 header.\nError occurred while decoding “IPv6 Destination Options…\nError occurred while decoding a generic IPv6 extension …\nError while parsing a IPv6 extension header.\nError while parsing a IPv6 extension header.\nIPv6 Header Flow Label field present in <code>crate::Ipv6Header</code>.\nError occurred while decoding an IPv6 fragment header.\nError occurred in the IPv6 layer.\nError occurred while decoding “IPv6 Hop-by-Hop Option” …\nError occurred verifying the payload length of an IPv6 …\nIPv6 Header “payload length” field present in an …\nError occurred while decoding “IPv6 Routing” extension …\nLayers on which an error can occur.\nError when parsing had to be aborted because of a length …\nError when parsing had to be aborted because of a length …\nError when different lengths are conflicting with each …\nType aggregating errors that can be caused by reading. …\nError when not enough space is available in a slice to …\nError while parsing a TCP extension header.\nError while parsing a TCP extension header.\nError occurred while decoding a TCP header.\nPayload length used when calculating the checksum of a …\nPayload length used when calculating the checksum of a …\nError occurred while decoding an UDP header.\nError occurred verifying the length of the UDP payload.\nPayload length used when calculating the checksum of a …\nPayload length used when calculating the checksum of a …\nError if a value exceeds the maximum allowed value.\nTypes of values that have a limited allowed value range …\nError occurred in the vlan header.\nVLAN identifier field present in a <code>crate::SingleVlanHeader</code>.\nVLAN PCP (Priority Code Point) field in a …\nValue that was disallowed.\nAdds an offset value to the <code>layer_start_offset</code> field.\nString that is used as a title for the error.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLayer in which the length error was encountered.\nLayer in which could not be written to the slice.\nOffset from the start of the parsed data to the layer …\nOffset from the start of the parsed data to the layer …\nLength limiting or exceeding the required length.\nLength limiting or exceeding the required length.\nSource of the outer length (e.g. Slice or a length …\nMaximum allowed value (inclusive).\nExpected minimum or maximum length conflicting with the <code>len</code>…\nExpected minimum length conflicting with the <code>actual_len</code> …\nType of value.\nError caused by the contents of the header.\nError caused by the contents of the header.\nErrors in an double vlan header encountered while decoding …\nError when decoding two VLAN headers via a <code>std::io::Read</code> …\nError when decoding a double VLAN header from a slice.\nIO error was encountered while reading header.\nError when an length error is encountered (e.g. unexpected …\nError when two vlan header were expected but the ether_type\nAdds an offset value to all slice length related fields.\nReturns the <code>err::double_vlan::HeaderError</code> value if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>HeaderReadError</code> is …\nNon-VLAN ether type encountered in the outer vlan header.\nIO error was encountered while reading header or expected …\nError when parsing had to be aborted because a length …\nError that can occur when reading from a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>LimitedReadError</code> …\nReturns the <code>err::LenError</code> value if it is of value <code>Len</code>. …\nError caused by the contents of the header.\nError caused by the contents of the header.\nError caused by the contents of the header.\nError when decoding the IP header part of a message.\nError when decoding an IP header via a <code>std::io::Read</code> …\nError when decoding the IP header part of a message.\nError when decoding an IP header from a slice.\nError when writing IPv4 extension headers.\nIO error was encountered while reading header.\nIO error encountered while writing.\nError in the IPv4 or IPv6 header.\nError when decoding an IP header or IP extension header.\nError in the IPv4 extension headers (only authentication …\nIPv4 extensions can not be serialized (e.g. order is not …\nError when the ipv4 internet header length is smaller then …\nError in the IPv6 extension headers.\nIPv6 extensions can not be serialized (e.g. order is not …\nError when decoding an IP header from a slice.\nErrors caused by conflicts with the lengths defined in the …\nError when an length error is encountered (e.g. unexpected …\nError when an length error is encountered (e.g. unexpected …\nLength related errors (e.g. not enough data in slice).\nErrors that can occur when slicing the IP part of a packet.\nError when the IP header version field is not equal to 4 …\nAdds an offset value to all slice length related fields.\nAdds an offset value to all slice length related fields.\nReturns the <code>err::ip::HeaderError</code> value if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>HeaderReadError</code> is …\nReturns a reference to the <code>std::io::Error</code> if the value is …\nReturns a reference to the …\nReturns a reference to the …\nReturns the <code>err::LenError</code> value if the <code>HeaderReadError</code> is …\nThe internet header length that was too small.\nThe unexpected version number in the IP header.\nError caused by the contents of the header.\nError caused by the contents of the header.\nError caused by the contents of the header.\nErrors that can be encountered while decoding an IP …\nError when decoding an IP authentication header via a …\nError when decoding an IP authentication header via a …\nError when decoding an IP authentication header from a …\nError when creating an <code>crate::IpAuthHeader</code> and the length …\nIO error was encountered while reading header.\nIO error was encountered while reading header.\nError when parsing had to be aborted because a length …\nError when an length error is encountered (e.g. unexpected …\nError when the payload length is bigger then …\nError when the ICV length can not be represented as a …\nError when the payload length is zero and therefor too …\nAdds an offset value to all slice length related fields.\nReturns the <code>err::ip_auth::HeaderError</code> value if it is of …\nReturns the <code>crate::err::ip_auth::HeaderError</code> value if it …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>HeaderReadError</code> is …\nReturns the <code>std::io::Error</code> value if the …\nReturns the <code>crate::err::LenError</code> value if it is of value …\nError caused by the contents of a header.\nErrors while serializing or determining the next_header of …\nError when decoding the IP extension header.\nError when decoding IP extension headers from a slice.\nError in the IPv4 extension headers (only authentication …\nError within the IPv4 extensions headers.\nError in the IPv6 extension headers.\nError within the IPv6 extensions headers.\nError when an length error is encountered (e.g. unexpected …\nReturns the <code>crate::err::ipv6_exts::HeaderError</code> if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>crate::err::LenError</code> if the error is an Len.\nError if a slice can not be used as options data in …\nError caused by the contents of the header.\nError caused by the contents of the header.\nError while slicing an ipv4 extension header.\nError while slicing the header.\nError when decoding the IPv4 part of a message.\nError when the ipv4 internet header length is smaller then …\nError when decoding an IPv4 header via a <code>std::io::Read</code> …\nError when decoding an IPv4 header from a slice.\nIO error was encountered while reading header.\nError when an length error is encountered (e.g. unexpected …\nLength related errors (e.g. not enough data in slice).\nErrors that can occur when slicing the IPv4 part of a …\nError when the IPv4 header version field is not equal to 4.\nAdds an offset value to all slice length related fields.\nInvalid length.\nReturns the <code>err::ipv4::HeaderError</code> value if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>HeaderReadError</code> is …\nThe internet header length that was too small.\nThe unexpected version number in the IPv4 header.\nData was not serializable because of its content.\nError when a header in <code>crate::Ipv4Extensions</code> is never …\nErrors in content of IPv4 header extensions that prevent …\nError when writing IPv4 extension headers.\nIO error encountered while writing.\nReturns a reference to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a reference to the <code>std::io::Error</code> if the value is …\nIpNumber of the header which was not referenced.\nError caused by the contents of the header.\nError caused by the contents of the header.\nError while slicing an ipv6 extension header.\nError while slicing the header.\nError when decoding the IPv6 header.\nError when decoding an IPv6 header via a <code>std::io::Read</code> …\nError when decoding an IPv6 header from a slice.\nIO error was encountered while reading header.\nError when an length error is encountered (e.g. unexpected …\nLength related errors (e.g. not enough data in slice).\nErrors that can occur when slicing the IPv6 part of a …\nError when the IPv6 header version field is not equal to 6.\nAdds an offset value to all slice length related fields.\nReturns the <code>err::ipv6::HeaderError</code> value if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>HeaderReadError</code> is …\nThe unexpected version number in the IPv6 header.\nError caused by the contents of the header.\nError caused by the contents of the header.\nError caused by the contents of the header.\nData was not serializable because of its content.\nError when a header in <code>crate::Ipv6Extensions</code> is never …\nError when creating an <code>crate::Ipv6RawExtHeader</code> and the …\nErrors in content of IPv6 header extensions that prevent …\nError when decoding IPv6 extension headers.\nError when decoding IPv6 extension headers via a …\nError when decoding IPv6 extension headers via a …\nError when decoding IPv6 extension headers from a slice.\nError when writing IPv6 extension headers.\nError if the ipv6 hop by hop header does not occur …\nError when a hop-by-hop header is not referenced as the …\nIO error was encountered while reading header.\nIO error was encountered while reading header.\nIO error encountered while writing.\nError in the ip authentication header.\nError when parsing had to be aborted because a length …\nError when an length error is encountered (e.g. unexpected …\nError when the payload length is bigger then …\nError when the payload length is smaller then …\nError when the payload length can not be represented as a …\nAdds an offset value to all slice length related fields.\nReturns the <code>crate::err::ip_auth::HeaderError</code> value if it …\nReturns the <code>crate::err::ipv6_exts::HeaderError</code> if the …\nReturns a reference to the …\nReturns the <code>err::ipv6_exts::HeaderError</code> value if the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the …\nReturns a reference to the <code>std::io::Error</code> if the value is …\nReturns the <code>std::io::Error</code> value if the <code>HeaderReadError</code> is …\nReturns the <code>crate::err::LenError</code> value if it is of value …\nReturns the <code>crate::err::LenError</code> if the error is an Len.\nIpNumber of the header which was not referenced.\nError while writing packet\nError if ICMPv6 is packaged in an IPv4 packet (it is …\nError when an Icmpv6 payload is found in an IPv4 packet.\nIO error while writing packet.\nError when decoding starting at an IP header (v4 or v6).\nError when decoding an IPv4 header.\nError if the IPv4 extensions can not be serialized because …\nError when decoding an IPv4 extension header.\nError when decoding an IPv6 header.\nError if the IPv6 extensions can not be serialized because …\nError when decoding an IPv6 extension header.\nLength related errors (e.g. not enough data in slice).\nError if the length of the payload is too big to be …\nError if the length of the payload is too big to be …\nError when slicing an packet from downwards (both starting …\nError when decoding a TCP header.\nError while calculating the checksum in a transport header.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>BuildWriteError</code> is …\nReturns the <code>crate::err::ipv4_exts::ExtsWalkError</code> value if …\nReturns the <code>crate::err::ipv6_exts::ExtsWalkError</code> value if …\nReturns true if the <code>BuildWriteError</code> is a <code>Icmpv6InIpv4</code>.\nReturns the <code>crate::err::ValueTooBigError</code> value if the …\nError caused by the contents of the header.\nError caused by the contents of the header.\nError when the data_offset is so small that the data would …\nErrors that can be encountered while decoding a TCP header.\nError when decoding a TCP header via a <code>std::io::Read</code> …\nError when decoding a TCP header from a slice.\nIO error was encountered while reading header.\nError when an length error is encountered (e.g. unexpected …\nAdds an offset value to all slice length related fields.\nReturns the <code>err::tcp::HeaderError</code> value if it is of value …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the <code>std::io::Error</code> value if the <code>HeaderReadError</code> is …\nBad Length\nICMP destination unreachable code for “Communication …\nICMP destination unreachable code for “Host Unreachable…\nICMP destination unreachable code for “Host Precedence …\nICMP destination unreachable code for “Communication …\nICMP destination unreachable code for “Destination Host …\nICMP destination unreachable code for “Source Host …\nICMP destination unreachable code for “Fragmentation …\nICMP destination unreachable code for “Net Unreachable”…\nICMP destination unreachable code for “Communication …\nICMP destination unreachable code for “Destination …\nICMP destination unreachable code for “Port Unreachable…\nICMP destination unreachable code for “Precedence cutoff …\nICMP destination unreachable code for “Protocol …\nICMP destination unreachable code for “Source Route …\nICMP destination unreachable code for “Destination Host …\nICMP destination unreachable code for “Destination …\nICMPv4 “Parameter Problem” code value for “Bad Length…\nICMPv4 “Parameter Problem” code value for “Missing a …\nICMPv4 “Parameter Problem” code value for “Pointer …\nICMPv4 “Redirect” code value for “Redirect Datagram …\nICMPv4 “Redirect” code value for “Redirect Datagram …\nICMPv4 “Redirect” code value for “Redirect Datagram …\nICMPv4 “Redirect” code value for “Redirect Datagram …\nICMPv4 “Time Exceeded” code value for “Fragment …\nICMPv4 “Time Exceeded” code value for “Time to Live …\n“Destination Unreachable” ICMP header for IPv4 …\nCannot forward because packet administratively filtered …\nFragment reassembly time exceeded.\nFragmentation would be needed but the don’t fragment bit …\nHost unreachable error.\nRequired level of precidence not supported (from RFC 1812)\nCommunication with Destination Host is Administratively …\nDestination Host Unknown (no route to host known) (from …\nSource Host Isolated - obsolete (from RFC 1122)\nThe size in bytes/octets of a timestamp request or …\nMissing a Required Option\nNetwork unreachable error.\nCommunication with Destination Network is Administratively …\nDestination Network Unknown (from RFC 1122)\nThe header of an ICMPv4 Parameter Problems (contents up to …\nIdentifies the octet where an error was detected.\nPort unreachable error.\nPacket was below minimum precidence (from RFC 1812)\nTransport protocol not supported error.\nCode value in an ICMPv4 Redirect message.\nRedirect Datagram for the Host\nRedirect Datagram for the Network (or subnet)\nRedirect datagrams for the Type of Service and Host\nRedirect Datagram for the Type of Service and Network\nDeprecated use <code>TimestampMessage::LEN</code> instead.\nSource Route Failed\nICMPv4 type value indicating a “Address Mask Request …\nICMPv4 type value indicating a “Address Mask Reply …\nICMPv4 type value indicating a “Alternate Host Address …\nICMPv4 type value indicating a “Destination Unreachable…\nICMPv4 type value indicating a “Echo Reply” message …\nICMPv4 type value indicating a “Echo Request” message …\nICMPv4 type value indicating a “Information Reply …\nICMPv4 type value indicating a “Information Request …\nICMPv4 type value indicating a “Parameter Problem” …\nICMPv4 type value indicating a “Redirect” message …\nICMPv4 type value indicating a “Router Advertisement” …\nICMPv4 type value indicating a “Router Solicitation” …\nICMPv4 type value indicating a “Source Quench …\nICMPv4 type value indicating a “Timestamp” message …\nICMPv4 type value indicating a “Timestamp Reply” …\nICMPv4 type value indicating a “Time Exceeded” message …\nCode values for ICMPv4 time exceeded message.\nA ICMPv4 timestamp or timestamp response message.\nDestination Host Unreachable for Type of Service (from RFC …\nDestination Network Unreachable for Type of Service (from …\nTime-to-live exceeded in transit.\nReturns the icmp code value of the destination unreachable …\nReturns the <code>u8</code> value of the code.\nReturns the <code>u8</code> value of the code.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecodes the timestamp message part of an ICMPv4 message.\nTries to convert a code <code>u8</code> value to a <code>RedirectCode</code> value.\nTries to convert a code <code>u8</code> value to a <code>TimeExceededCode</code> …\nTries to convert the code <code>u8</code> value and next_hop_mtu to a …\nTries to convert the code <code>u8</code> value and pointer to a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAddress unreachable\nBeyond scope of source address\nICMPv6 destination unreachable code for “address …\nICMPv6 destination unreachable code for “beyond scope of …\nICMPv6 destination unreachable code for “no route to …\nICMPv6 destination unreachable code for “port unreachable…\nICMPv6 destination unreachable code for “communication …\nICMPv6 destination unreachable code for “reject route to …\nICMPv6 destination unreachable code for “source address …\nICMPv6 parameter problem code for “erroneous header …\nICMPv6 parameter problem code for “Extension header …\nICMPv6 parameter problem code for “Extension header too …\nICMPv6 parameter problem code for “IPv6 First Fragment …\nICMPv6 parameter problem code for “Option too big” …\nICMPv6 parameter problem code for “SR Upper-layer Header …\nICMPv6 parameter problem code for “Too many extension …\nICMPv6 parameter problem code for “Too many options in …\nICMPv6 parameter problem code for “unrecognized IPv6 …\nICMPv6 parameter problem code for “unrecognized Next …\nICMPv6 parameter problem code for “Unrecognized Next …\nICMPv6 time exceeded code for “fragment reassembly time …\nICMPv6 time exceeded code for “hop limit exceeded in …\n“Destination Unreachable” ICMPv6 code containing a …\nErroneous header field encountered (from RFC 4443)\nExtension header chain too long (from RFC 8883)\nExtension header too big (from RFC 8883)\n“fragment reassembly time exceeded”\n“hop limit exceeded in transit”\nIPv6 First Fragment has incomplete IPv6 Header Chain (from …\nThe maximum number of bytes/octets the ICMPv6 part of a …\nNo route to destination\nOption too big (from RFC 8883)\nCode values for ICMPv6 parameter problem messages.\nICMPv6 parameter problem header.\nPort unreachable\nCommunication with destination administratively prohibited\nReject route to destination\nSource address failed ingress/egress policy\nSR Upper-layer Header Error (from RFC 8754).\nICMPv6 type value indicating a “Destination Unreachable…\nICMPv6 type value indicating an “Echo Reply” message.\nICMPv6 type value indicating an “Echo Request” message.\nICMPv6 type value indicating a “Extended Echo Reply” …\nICMPv6 type value indicating a “Extended Echo Request” …\nICMPv6 type value indicating a “Inverse Neighbor …\nICMPv6 type value indicating a “Inverse Neighbor …\nICMPv6 type value indicating a “Multicast Listener Query…\nICMPv6 type value indicating a “Multicast Listener Done…\nICMPv6 type value indicating a “Multicast Listener Report…\nICMPv6 type value indicating a “Neighbor Advertisement”…\nICMPv6 type value indicating a “Neighbor Solicitation” …\nICMPv6 type value indicating a “Packet Too Big” …\nICMPv6 type value indicating a “Parameter Problem” …\nICMPv6 type value indicating a “Redirect Message” …\nICMPv6 type value indicating a “Router Advertisement” …\nICMPv6 type value indicating a “Router Renumbering” …\nICMPv6 type value indicating a “Router Solicitation” …\nICMPv6 type value indicating a “Time Exceeded” message.\nCode values for ICMPv6 time exceeded message.\nToo many extension headers (from RFC 8883)\nToo many options in extension header (from RFC 8883)\nUnrecognized IPv6 option encountered (from RFC 4443)\nUnrecognized Next Header type encountered (from RFC 4443)\nUnrecognized Next Header type encountered by intermediate …\nThe code can offer additional informations about what kind …\nReturns the code value of the destination unreachable …\nReturns the <code>u8</code> value of the code.\nReturns the <code>u8</code> value of the code.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts the u8 code value from an ICMPv6 “destination …\nTries to convert a code <code>u8</code> value to a <code>ParameterProblemCode</code> …\nTries to convert a code <code>u8</code> value to a <code>TimeExceededCode</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIdentifies the octet offset within the invoking packet …\nEncapsulated reader with an maximum allowed read length.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLayer that is currently read (used for len error).\nOffset of the layer that is currently read (used for len …\nSource of the maximum length (used for len error).\nMaximum len that still can be read (on the current layer).\nSetup a new limited reader.\nTry read the given buf length from the reader.\nLen that was read on the current layer.\nSet current position as starting position for a layer.\nConsumes LimitedReader and returns the reader.\nActive Networks [Bob_Braden]\nany distributed file system …\nany host internal protocol …\nany local network [Internet_Assigned_Numbers_Authority]\nany 0-hop protocol [Internet_Assigned_Numbers_Authority]\nARGUS (deprecated) [Robert_W_Scheifler]\nARIS [Nancy_Feldman]\nAuthentication Header [RFC4302]\nAuthentication Header [RFC4302]\nAX.25 Frames [Brian_Kantor]\nBBN RCC Monitoring [Steve_Chipman]\nBNA [Gary Salamon]\nBackroom SATNET Monitoring [Steven_Blumenthal]\nCBT [Tony_Ballardie]\nCFTP [Forsdick, H., “CFTP”, Network Message, Bolt …\nChaos [J_Noel_Chiappa]\nCompaq Peer Protocol [Victor_Volpe]\nComputer Protocol Heart Beat [David Mittnacht]\nComputer Protocol Network Executive [David Mittnacht]\nCombat Radio Transport Protocol [Robert_Sautter]\nCombat Radio User Datagram [Robert_Sautter]\nDatagram Congestion Control Protocol [RFC4340]\nDCN Measurement Subsystems [David_Mills]\nDatagram Delivery Protocol [Wesley_Craig]\nD-II Data Exchange (DDX) [John_Worley]\nDissimilar Gateway Protocol [M/A-COM Government Systems, …\nDynamic Source Routing Protocol [RFC4728]\nExterior Gateway Protocol [RFC888] [David_Mills]\nEIGRP [RFC7868]\nEMCON [mystery contact]\nEncapsulation Header [RFC1241][Robert_Woodburn]\nEncapsulating Security Payload [RFC4303]\nEncapsulating Security Payload [RFC4303]\nEthernet-within-IP Encapsulation [RFC3378]\nUse for experimentation and testing\nUse for experimentation and testing\nUse for experimentation and testing\nUse for experimentation and testing\nFibre Channel [Murali_Rajagopal][RFC6172]\nFIRE [Criag_Partridge]\nGateway-to-Gateway [RFC823]\nGMTP [[RXB5]]\nGeneric Routing Encapsulation [RFC2784][Tony_Li]\nHost Identity Protocol [RFC7401]\nHost Monitoring [RFC869][Bob_Hinden]\nInteractive Agent Transfer Protocol [John_Murphy]\nInternet Control Message [RFC792]\nInter-Domain Policy Routing Protocol [Martha_Steenstrup]\nIDPR Control Message Transport Proto [Martha_Steenstrup]\nInter-Domain Routing Protocol [Sue_Hares]\nIpsilon Flow Management Protocol [Bob_Hinden][November …\nInternet Group Management [RFC1112]\nany private interior gateway (used by Cisco for their …\nIL Transport Protocol [Dave_Presotto]\nIntegrated Net Layer Security  TUBA [K_Robert_Glenn]\nInternet Packet Core Utility [Steven_Blumenthal]\nIP-within-IP Encapsulation Protocol [John_Ioannidis]\nIPLT [[Hollbach]]\nInternet Pluribus Packet Core [Steven_Blumenthal]\nIPv4 encapsulation [RFC2003]\nIPv6 encapsulation [RFC2473]\nDestination Options for IPv6 [RFC8200]\nDestination Options for IPv6 [RFC8200]\nFragment Header for IPv6 [Steve_Deering]\nFragment Header for IPv6 [Steve_Deering]\nIPv6 Hop-by-Hop Option [RFC8200]\nIPv6 Hop-by-Hop Option [RFC8200]\nIPv6 ICMP next-header type [RFC4443]\nNo Next Header for IPv6 [RFC8200]\nRouting Header for IPv6 [Steve_Deering]\nRouting Header for IPv6 [Steve_Deering]\nIPX in IP [CJ_Lee]\nIP Payload Compression Protocol [RFC2393]\nInternet Reliable Transaction [RFC938] [Trudy_Miller]\nISIS over IPv4 [Tony_Przygienda]\nISO Internet Protocol [Marshall_T_Rose]\nISO Transport Protocol Class 4 [RFC905] [mystery contact]\nKryptolan [Paul Liu]\nLocus Address Resolution Protocol [Brian Horn]\nLayer Two Tunneling Protocol [RFC3931][Bernard_Aboba]\nLeaf-1 [Barry_Boehm]\nLeaf-2 [Barry_Boehm]\nMANET Protocols [RFC5498]\nMERIT Internodal Protocol [Hans_Werner_Braun]\nMFE Network Services Protocol [Shuttleworth, B., “A …\nMobile Internetworking Control Pro. (deprecated) …\nIP Mobility [Charlie_Perkins]\nMobilityHeader [RFC6275]\nMobilityHeader [RFC6275]\n[RFC4023]\nMulticast Transport Protocol [Susie_Armstrong]\nMultiplexing [Cohen, D. and J. Postel, “Multiplexing …\nNBMA Address Resolution Protocol [RFC1735]\nBulk Data Transfer Protocol [RFC969] [David_Clark]\nNSFNET-IGP [Hans_Werner_Braun]\nNetwork Voice Protocol [RFC741][Steve_Casner]\nOSPFIGP [RFC1583][RFC2328][RFC5340][John_Moy]\nPGM Reliable Transport Protocol [Tony_Speakman]\nProtocol Independent Multicast [RFC7761][Dino_Farinacci]\nPrivate IP Encapsulation within IP [Bernhard_Petri]\nPNNI over IP [Ross_Callon]\nPacket Radio Measurement [Zaw_Sing_Su]\nPerformance Transparency Protocol [Michael_Welzl]\nPUP\nPacket Video Protocol [Steve_Casner]\nQNX [Michael_Hunter]\nReliable Data Protocol [RFC908] [Bob_Hinden]\nRobust Header Compression [RFC5858]\nReservation Protocol [RFC2205][RFC3209][Bob_Braden]\nRSVP-E2E-IGNORE [RFC3175]\nMIT Remote Virtual Disk Protocol [Michael_Greenwald]\nSATNET and Backroom EXPAK [Steven_Blumenthal]\nSATNET Monitoring [Steven_Blumenthal]\nSemaphore Communications Sec. Pro. [Howard_Hart]\nSCPS [Robert_Durst]\nStream Control Transmission Protocol [Randall_R_Stewart]\nSource Demand Routing Protocol [Deborah_Estrin]\nSECURE-VMTP [Dave_Cheriton]\nShim6 Protocol [RFC5533]\nSimple Message Protocol [Leif_Ekblad]\nSitara Networks Protocol [Manickam_R_Sridhar]\nSKIP [Tom_Markson]\nSimple Multicast Protocol (deprecated) [Jon_Crowcroft]…\nSprite RPC Protocol [Welch, B., “The Sprite Remote …\nSecure Packet Shield [Bill_McIntosh]\nSpectraLink Radio Protocol [Mark_Hamilton]\nSSCOPMCE [Kurt_Waber]\nSchedule Transfer Protocol [Jean_Michel_Pittet]\nStream [RFC1190] [RFC1819]\nSUN ND PROTOCOL-Temporary [William_Melohn]\nIP with Encryption (deprecated) [John_Ioannidis]\nTCF [Guillermo_A_Loyola]\nTransmission Control [RFC793]\nThird Party Connect Protocol [Stuart_A_Friedberg]\nTransport Layer Security Protocol using Kryptonet key …\nTP++ Transport Protocol [Dirk_Fromhein]\nTrunk-1 [Barry_Boehm]\nTrunk-2 [Barry_Boehm]\nTransaction Transport Protocol or Internet Protocol …\nUser Datagram [RFC768] [Jon_Postel]\nUDPLite [RFC3828]\nUTI [Peter_Lothberg]\nVINES [Brian Horn]\nVISA Protocol [Gene_Tsudik]\nVMTP [Dave_Cheriton]\nVirtual Router Redundancy Protocol [RFC5798]\nWIDEBAND EXPAK [Steven_Blumenthal]\nWIDEBAND Monitoring [Steven_Blumenthal]\nWrapped Encapsulating Security Payload [RFC5840]\nWang Span Network [Victor Dafoulas]\nCross Net Debugger [Haverty, J., “XNET Formats for …\nXEROX NS IDP\nXTP [Greg_Chesson]\n<code>u8</code> identifying the “end of options list” in the tcp …\n<code>u8</code> identifying a “maximum segment size” tcp option.\n<code>u8</code> identifying a “no operation” tcp option.\n<code>u8</code> identifying a “selective acknowledgement” tcp …\n<code>u8</code> identifying a “selective acknowledgement permitted” …\n<code>u8</code> identifying a “timestamp and echo of previous …\n<code>u8</code> identifying a “window scaling” tcp option.\nLength in octets/bytes of the “end” tcp option …\nLength in octets/bytes of the “maximum segment size” …\nLength in octets/bytes of the “no operation” tcp …\nLength in octets/bytes of the “selective acknowledgement …\nLength in octets/bytes of the “timestamp and echo of …\nLength in octets/bytes of the “window scaling” tcp …")