<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A zero allocation library for parsing &#38; writing a bunch of packet based protocols (EthernetII, IPv4, IPv6, UDP, TCP …)."><title>etherparse - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="etherparse" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../etherparse/index.html">etherparse</a><span class="version">0.14.3</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#what-is-etherparse" title="What is etherparse?">What is etherparse?</a></li><li><a href="#how-to-parse-network-packages" title="How to parse network packages?">How to parse network packages?</a><ul><li><a href="#slicing-the-packet" title="Slicing the packet">Slicing the packet</a></li><li><a href="#deserializing-all-headers-into-structs" title="Deserializing all headers into structs">Deserializing all headers into structs</a></li><li><a href="#manually-slicing-only-one-packet-layer" title="Manually slicing only one packet layer">Manually slicing only one packet layer</a></li><li><a href="#manually-slicing--parsing-only-headers" title="Manually slicing &#38; parsing only headers">Manually slicing &amp; parsing only headers</a></li></ul></li><li><a href="#how-to-generate-fake-packet-data" title="How to generate fake packet data?">How to generate fake packet data?</a><ul><li><a href="#packet-builder" title="Packet Builder">Packet Builder</a></li><li><a href="#manually-serializing-each-header" title="Manually serializing each header">Manually serializing each header</a></li></ul></li><li><a href="#references" title="References">References</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>etherparse</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/etherparse/lib.rs.html#1-405">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A zero allocation library for parsing &amp; writing a bunch of packet based protocols (EthernetII, IPv4, IPv6, UDP, TCP …).</p>
<p>Currently supported are:</p>
<ul>
<li>Ethernet II</li>
<li>IEEE 802.1Q VLAN Tagging Header</li>
<li>IPv4</li>
<li>IPv6 (supporting the most common extension headers, but not all)</li>
<li>UDP</li>
<li>TCP</li>
<li>ICMP &amp; ICMPv6 (not all message types are supported)</li>
</ul>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
etherparse = &quot;0.14&quot;</code></pre></div><h2 id="what-is-etherparse"><a class="doc-anchor" href="#what-is-etherparse">§</a>What is etherparse?</h2>
<p>Etherparse is intended to provide the basic network parsing functions that allow for easy analysis, transformation or generation of recorded network data.</p>
<p>Some key points are:</p>
<ul>
<li>It is completely written in Rust and thoroughly tested.</li>
<li>Special attention has been paid to not use allocations or syscalls.</li>
<li>The package is still in development and can &amp; will still change.</li>
<li>The current focus of development is on the most popular protocols in the internet &amp; transport layer.</li>
</ul>
<h2 id="how-to-parse-network-packages"><a class="doc-anchor" href="#how-to-parse-network-packages">§</a>How to parse network packages?</h2>
<p>Etherparse gives you two options for parsing network packages automatically:</p>
<h3 id="slicing-the-packet"><a class="doc-anchor" href="#slicing-the-packet">§</a>Slicing the packet</h3>
<p>Here the different components in a packet are separated without parsing all their fields. For each header a slice is generated that allows access to the fields of a header.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">match </span>SlicedPacket::from_ethernet(<span class="kw-2">&amp;</span>packet) {
    <span class="prelude-val">Err</span>(value) =&gt; <span class="macro">println!</span>(<span class="string">"Err {:?}"</span>, value),
    <span class="prelude-val">Ok</span>(value) =&gt; {
        <span class="macro">println!</span>(<span class="string">"link: {:?}"</span>, value.link);
        <span class="macro">println!</span>(<span class="string">"vlan: {:?}"</span>, value.vlan);
        <span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net); <span class="comment">// contains ip
        </span><span class="macro">println!</span>(<span class="string">"transport: {:?}"</span>, value.transport);
    }
}</code></pre></div>
<p>This is the faster option if your code is not interested in all fields of all the headers. It is a good choice if you just want filter or find packages based on a subset of the headers and/or their fields.</p>
<p>Depending from which point downward you want to slice a package check out the functions:</p>
<ul>
<li><a href="struct.SlicedPacket.html#method.from_ethernet" title="associated function etherparse::SlicedPacket::from_ethernet"><code>SlicedPacket::from_ethernet</code></a> for parsing from an Ethernet II header downwards</li>
<li><a href="struct.SlicedPacket.html#method.from_ether_type" title="associated function etherparse::SlicedPacket::from_ether_type"><code>SlicedPacket::from_ether_type</code></a> for parsing a slice starting after an Ethernet II header</li>
<li><a href="struct.SlicedPacket.html#method.from_ip" title="associated function etherparse::SlicedPacket::from_ip"><code>SlicedPacket::from_ip</code></a> for parsing from an IPv4 or IPv6 downwards</li>
</ul>
<p>In case you want to parse cut off packets (e.g. packets returned in in ICMP message) you can use the “lax” parsing methods:</p>
<ul>
<li><a href="struct.LaxSlicedPacket.html#method.from_ethernet" title="associated function etherparse::LaxSlicedPacket::from_ethernet"><code>LaxSlicedPacket::from_ethernet</code></a> for parsing from an Ethernet II header downwards</li>
<li><a href="struct.LaxSlicedPacket.html#method.from_ether_type" title="associated function etherparse::LaxSlicedPacket::from_ether_type"><code>LaxSlicedPacket::from_ether_type</code></a> for parsing a slice starting after an Ethernet II header</li>
<li><a href="struct.LaxSlicedPacket.html#method.from_ip" title="associated function etherparse::LaxSlicedPacket::from_ip"><code>LaxSlicedPacket::from_ip</code></a> for parsing from an IPv4 or IPv6 downwards</li>
</ul>
<h3 id="deserializing-all-headers-into-structs"><a class="doc-anchor" href="#deserializing-all-headers-into-structs">§</a>Deserializing all headers into structs</h3>
<p>This option deserializes all known headers and transfers their contents to header structs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">match </span>PacketHeaders::from_ethernet_slice(<span class="kw-2">&amp;</span>packet) {
    <span class="prelude-val">Err</span>(value) =&gt; <span class="macro">println!</span>(<span class="string">"Err {:?}"</span>, value),
    <span class="prelude-val">Ok</span>(value) =&gt; {
        <span class="macro">println!</span>(<span class="string">"link: {:?}"</span>, value.link);
        <span class="macro">println!</span>(<span class="string">"vlan: {:?}"</span>, value.vlan);
        <span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net); <span class="comment">// contains ip
        </span><span class="macro">println!</span>(<span class="string">"transport: {:?}"</span>, value.transport);
    }
}</code></pre></div>
<p>This option is slower then slicing when only few fields are accessed. But it can be the faster option or useful if you are interested in most fields anyways or if you want to re-serialize the headers with modified values.</p>
<p>Depending from which point downward you want to unpack a package check out the functions</p>
<ul>
<li><a href="struct.PacketHeaders.html#method.from_ethernet_slice" title="associated function etherparse::PacketHeaders::from_ethernet_slice"><code>PacketHeaders::from_ethernet_slice</code></a> for parsing from an Ethernet II header downwards</li>
<li><a href="struct.PacketHeaders.html#method.from_ether_type" title="associated function etherparse::PacketHeaders::from_ether_type"><code>PacketHeaders::from_ether_type</code></a> for parsing a slice starting after an Ethernet II header</li>
<li><a href="struct.PacketHeaders.html#method.from_ip_slice" title="associated function etherparse::PacketHeaders::from_ip_slice"><code>PacketHeaders::from_ip_slice</code></a> for parsing from an IPv4 or IPv6 downwards</li>
</ul>
<p>In case you want to parse cut off packets (e.g. packets returned in in ICMP message) you can use the “lax” parsing methods:</p>
<ul>
<li><a href="struct.LaxPacketHeaders.html#method.from_ethernet" title="associated function etherparse::LaxPacketHeaders::from_ethernet"><code>LaxPacketHeaders::from_ethernet</code></a> for parsing from an Ethernet II header downwards</li>
<li><a href="struct.LaxPacketHeaders.html#method.from_ether_type" title="associated function etherparse::LaxPacketHeaders::from_ether_type"><code>LaxPacketHeaders::from_ether_type</code></a> for parsing a slice starting after an Ethernet II header</li>
<li><a href="struct.LaxPacketHeaders.html#method.from_ip" title="associated function etherparse::LaxPacketHeaders::from_ip"><code>LaxPacketHeaders::from_ip</code></a> for parsing from an IPv4 or IPv6 downwards</li>
</ul>
<h3 id="manually-slicing-only-one-packet-layer"><a class="doc-anchor" href="#manually-slicing-only-one-packet-layer">§</a>Manually slicing only one packet layer</h3>
<p>It is also possible to only slice one packet layer:</p>
<ul>
<li><a href="struct.Ethernet2Slice.html#method.from_slice_without_fcs" title="associated function etherparse::Ethernet2Slice::from_slice_without_fcs"><code>Ethernet2Slice::from_slice_without_fcs</code></a> &amp; <a href="struct.Ethernet2Slice.html#method.from_slice_with_crc32_fcs" title="associated function etherparse::Ethernet2Slice::from_slice_with_crc32_fcs"><code>Ethernet2Slice::from_slice_with_crc32_fcs</code></a></li>
<li><a href="struct.SingleVlanSlice.html#method.from_slice" title="associated function etherparse::SingleVlanSlice::from_slice"><code>SingleVlanSlice::from_slice</code></a> &amp; <a href="struct.DoubleVlanSlice.html#method.from_slice" title="associated function etherparse::DoubleVlanSlice::from_slice"><code>DoubleVlanSlice::from_slice</code></a></li>
<li><a href="enum.IpSlice.html#method.from_slice" title="associated function etherparse::IpSlice::from_slice"><code>IpSlice::from_slice</code></a> &amp; <a href="enum.LaxIpSlice.html#method.from_slice" title="associated function etherparse::LaxIpSlice::from_slice"><code>LaxIpSlice::from_slice</code></a></li>
<li><a href="struct.Ipv4Slice.html#method.from_slice" title="associated function etherparse::Ipv4Slice::from_slice"><code>Ipv4Slice::from_slice</code></a> &amp; <a href="struct.LaxIpv4Slice.html#method.from_slice" title="associated function etherparse::LaxIpv4Slice::from_slice"><code>LaxIpv4Slice::from_slice</code></a></li>
<li><a href="struct.Ipv6Slice.html#method.from_slice" title="associated function etherparse::Ipv6Slice::from_slice"><code>Ipv6Slice::from_slice</code></a> &amp; <a href="struct.LaxIpv6Slice.html#method.from_slice" title="associated function etherparse::LaxIpv6Slice::from_slice"><code>LaxIpv6Slice::from_slice</code></a></li>
<li><a href="struct.UdpSlice.html#method.from_slice" title="associated function etherparse::UdpSlice::from_slice"><code>UdpSlice::from_slice</code></a> &amp; <a href="struct.UdpSlice.html#method.from_slice_lax" title="associated function etherparse::UdpSlice::from_slice_lax"><code>UdpSlice::from_slice_lax</code></a></li>
<li><a href="struct.TcpSlice.html#method.from_slice" title="associated function etherparse::TcpSlice::from_slice"><code>TcpSlice::from_slice</code></a></li>
<li><a href="struct.Icmpv4Slice.html#method.from_slice" title="associated function etherparse::Icmpv4Slice::from_slice"><code>Icmpv4Slice::from_slice</code></a></li>
<li><a href="struct.Icmpv6Slice.html#method.from_slice" title="associated function etherparse::Icmpv6Slice::from_slice"><code>Icmpv6Slice::from_slice</code></a></li>
</ul>
<p>The resulting data types allow access to both the header(s) and the payload of the layer
and will automatically limit the length of payload if the layer has a length field limiting the
payload (e.g. the payload of IPv6 packets will be limited by the “payload length” field in
an IPv6 header).</p>
<h3 id="manually-slicing--parsing-only-headers"><a class="doc-anchor" href="#manually-slicing--parsing-only-headers">§</a>Manually slicing &amp; parsing only headers</h3>
<p>It is also possible just to parse headers. Have a look at the documentation for the
following [NAME]HeaderSlice.from_slice methods, if you want to just slice the header:</p>
<ul>
<li><a href="struct.Ethernet2HeaderSlice.html#method.from_slice" title="associated function etherparse::Ethernet2HeaderSlice::from_slice"><code>Ethernet2HeaderSlice::from_slice</code></a></li>
<li><a href="struct.SingleVlanHeaderSlice.html#method.from_slice" title="associated function etherparse::SingleVlanHeaderSlice::from_slice"><code>SingleVlanHeaderSlice::from_slice</code></a></li>
<li><a href="struct.DoubleVlanHeaderSlice.html#method.from_slice" title="associated function etherparse::DoubleVlanHeaderSlice::from_slice"><code>DoubleVlanHeaderSlice::from_slice</code></a></li>
<li><a href="struct.Ipv4HeaderSlice.html#method.from_slice" title="associated function etherparse::Ipv4HeaderSlice::from_slice"><code>Ipv4HeaderSlice::from_slice</code></a></li>
<li><a href="struct.Ipv4ExtensionsSlice.html#method.from_slice" title="associated function etherparse::Ipv4ExtensionsSlice::from_slice"><code>Ipv4ExtensionsSlice::from_slice</code></a></li>
<li><a href="struct.Ipv6HeaderSlice.html#method.from_slice" title="associated function etherparse::Ipv6HeaderSlice::from_slice"><code>Ipv6HeaderSlice::from_slice</code></a></li>
<li><a href="struct.Ipv6ExtensionsSlice.html#method.from_slice" title="associated function etherparse::Ipv6ExtensionsSlice::from_slice"><code>Ipv6ExtensionsSlice::from_slice</code></a></li>
<li><a href="struct.Ipv6RawExtHeaderSlice.html#method.from_slice" title="associated function etherparse::Ipv6RawExtHeaderSlice::from_slice"><code>Ipv6RawExtHeaderSlice::from_slice</code></a></li>
<li><a href="struct.IpAuthHeaderSlice.html#method.from_slice" title="associated function etherparse::IpAuthHeaderSlice::from_slice"><code>IpAuthHeaderSlice::from_slice</code></a></li>
<li><a href="struct.Ipv6FragmentHeaderSlice.html#method.from_slice" title="associated function etherparse::Ipv6FragmentHeaderSlice::from_slice"><code>Ipv6FragmentHeaderSlice::from_slice</code></a></li>
<li><a href="struct.UdpHeaderSlice.html#method.from_slice" title="associated function etherparse::UdpHeaderSlice::from_slice"><code>UdpHeaderSlice::from_slice</code></a></li>
<li><a href="struct.TcpHeaderSlice.html#method.from_slice" title="associated function etherparse::TcpHeaderSlice::from_slice"><code>TcpHeaderSlice::from_slice</code></a></li>
</ul>
<p>And for deserialization into the corresponding header structs have a look at:</p>
<ul>
<li><a href="struct.Ethernet2Header.html#method.read" title="associated function etherparse::Ethernet2Header::read"><code>Ethernet2Header::read</code></a> &amp; <a href="struct.Ethernet2Header.html#method.from_slice" title="associated function etherparse::Ethernet2Header::from_slice"><code>Ethernet2Header::from_slice</code></a></li>
<li><a href="struct.SingleVlanHeader.html#method.read" title="associated function etherparse::SingleVlanHeader::read"><code>SingleVlanHeader::read</code></a> &amp; <a href="struct.SingleVlanHeader.html#method.from_slice" title="associated function etherparse::SingleVlanHeader::from_slice"><code>SingleVlanHeader::from_slice</code></a></li>
<li><a href="struct.DoubleVlanHeader.html#method.read" title="associated function etherparse::DoubleVlanHeader::read"><code>DoubleVlanHeader::read</code></a> &amp; <a href="struct.DoubleVlanHeader.html#method.from_slice" title="associated function etherparse::DoubleVlanHeader::from_slice"><code>DoubleVlanHeader::from_slice</code></a></li>
<li><a href="enum.IpHeaders.html#method.read" title="associated function etherparse::IpHeaders::read"><code>IpHeaders::read</code></a> &amp; <a href="enum.IpHeaders.html#method.from_slice" title="associated function etherparse::IpHeaders::from_slice"><code>IpHeaders::from_slice</code></a></li>
<li><a href="struct.Ipv4Header.html#method.read" title="associated function etherparse::Ipv4Header::read"><code>Ipv4Header::read</code></a> &amp; <a href="struct.Ipv4Header.html#method.from_slice" title="associated function etherparse::Ipv4Header::from_slice"><code>Ipv4Header::from_slice</code></a></li>
<li><a href="struct.Ipv4Extensions.html#method.read" title="associated function etherparse::Ipv4Extensions::read"><code>Ipv4Extensions::read</code></a> &amp; <a href="struct.Ipv4Extensions.html#method.from_slice" title="associated function etherparse::Ipv4Extensions::from_slice"><code>Ipv4Extensions::from_slice</code></a></li>
<li><a href="struct.Ipv6Header.html#method.read" title="associated function etherparse::Ipv6Header::read"><code>Ipv6Header::read</code></a> &amp; <a href="struct.Ipv6Header.html#method.from_slice" title="associated function etherparse::Ipv6Header::from_slice"><code>Ipv6Header::from_slice</code></a></li>
<li><a href="struct.Ipv6Extensions.html#method.read" title="associated function etherparse::Ipv6Extensions::read"><code>Ipv6Extensions::read</code></a> &amp; <a href="struct.Ipv6Extensions.html#method.from_slice" title="associated function etherparse::Ipv6Extensions::from_slice"><code>Ipv6Extensions::from_slice</code></a></li>
<li><a href="struct.Ipv6RawExtHeader.html#method.read" title="associated function etherparse::Ipv6RawExtHeader::read"><code>Ipv6RawExtHeader::read</code></a> &amp; <a href="struct.Ipv6RawExtHeader.html#method.from_slice" title="associated function etherparse::Ipv6RawExtHeader::from_slice"><code>Ipv6RawExtHeader::from_slice</code></a></li>
<li><a href="struct.IpAuthHeader.html#method.read" title="associated function etherparse::IpAuthHeader::read"><code>IpAuthHeader::read</code></a> &amp; <a href="struct.IpAuthHeader.html#method.from_slice" title="associated function etherparse::IpAuthHeader::from_slice"><code>IpAuthHeader::from_slice</code></a></li>
<li><a href="struct.Ipv6FragmentHeader.html#method.read" title="associated function etherparse::Ipv6FragmentHeader::read"><code>Ipv6FragmentHeader::read</code></a> &amp; <a href="struct.Ipv6FragmentHeader.html#method.from_slice" title="associated function etherparse::Ipv6FragmentHeader::from_slice"><code>Ipv6FragmentHeader::from_slice</code></a></li>
<li><a href="struct.UdpHeader.html#method.read" title="associated function etherparse::UdpHeader::read"><code>UdpHeader::read</code></a> &amp; <a href="struct.UdpHeader.html#method.from_slice" title="associated function etherparse::UdpHeader::from_slice"><code>UdpHeader::from_slice</code></a></li>
<li><a href="struct.TcpHeader.html#method.read" title="associated function etherparse::TcpHeader::read"><code>TcpHeader::read</code></a> &amp; <a href="struct.TcpHeader.html#method.from_slice" title="associated function etherparse::TcpHeader::from_slice"><code>TcpHeader::from_slice</code></a></li>
<li><a href="struct.Icmpv4Header.html#method.read" title="associated function etherparse::Icmpv4Header::read"><code>Icmpv4Header::read</code></a> &amp; <a href="struct.Icmpv4Header.html#method.from_slice" title="associated function etherparse::Icmpv4Header::from_slice"><code>Icmpv4Header::from_slice</code></a></li>
<li><a href="struct.Icmpv6Header.html#method.read" title="associated function etherparse::Icmpv6Header::read"><code>Icmpv6Header::read</code></a> &amp; <a href="struct.Icmpv6Header.html#method.from_slice" title="associated function etherparse::Icmpv6Header::from_slice"><code>Icmpv6Header::from_slice</code></a></li>
</ul>
<h2 id="how-to-generate-fake-packet-data"><a class="doc-anchor" href="#how-to-generate-fake-packet-data">§</a>How to generate fake packet data?</h2><h3 id="packet-builder"><a class="doc-anchor" href="#packet-builder">§</a>Packet Builder</h3>
<p>The PacketBuilder struct provides a high level interface for quickly creating network packets. The PacketBuilder will automatically set fields which can be deduced from the content and compositions of the packet itself (e.g. checksums, lengths, ethertype, ip protocol number).</p>
<p><a href="https://github.com/JulianSchmid/etherparse/blob/0.14.3/examples/write_udp.rs">Example:</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>etherparse::PacketBuilder;

<span class="kw">let </span>builder = PacketBuilder::
    ethernet2([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],     <span class="comment">//source mac
               </span>[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]) <span class="comment">//destination mac
    </span>.ipv4([<span class="number">192</span>,<span class="number">168</span>,<span class="number">1</span>,<span class="number">1</span>], <span class="comment">//source ip
          </span>[<span class="number">192</span>,<span class="number">168</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="comment">//destination ip
          </span><span class="number">20</span>)            <span class="comment">//time to life
    </span>.udp(<span class="number">21</span>,    <span class="comment">//source port
         </span><span class="number">1234</span>); <span class="comment">//destination port

//payload of the udp packet
</span><span class="kw">let </span>payload = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];

<span class="comment">//get some memory to store the result
</span><span class="kw">let </span><span class="kw-2">mut </span>result = Vec::&lt;u8&gt;::with_capacity(builder.size(payload.len()));

<span class="comment">//serialize
//this will automatically set all length fields, checksums and identifiers (ethertype &amp; protocol)
//before writing the packet out to "result"
</span>builder.write(<span class="kw-2">&amp;mut </span>result, <span class="kw-2">&amp;</span>payload).unwrap();</code></pre></div>
<p>There is also an <a href="https://github.com/JulianSchmid/etherparse/blob/0.14.3/examples/write_tcp.rs">example for TCP packets</a> available.</p>
<p>Check out the <a href="struct.PacketBuilder.html">PacketBuilder documentation</a> for more information.</p>
<h3 id="manually-serializing-each-header"><a class="doc-anchor" href="#manually-serializing-each-header">§</a>Manually serializing each header</h3>
<p>Alternatively it is possible to manually build a packet
(<a href="https://github.com/JulianSchmid/etherparse/blob/0.14.3/examples/write_ipv4_udp.rs">example</a>).
Generally each struct representing a header has a “write” method that allows it to be
serialized. These write methods sometimes automatically calculate checksums and fill them
in. In case this is unwanted behavior (e.g. if you want to generate a packet with an invalid
checksum), it is also possible to call a “write_raw” method that will simply serialize the data
without doing checksum calculations.</p>
<p>Read the documentations of the different methods for a more details:</p>
<ul>
<li><a href="struct.Ethernet2Header.html#method.to_bytes" title="method etherparse::Ethernet2Header::to_bytes"><code>Ethernet2Header::to_bytes</code></a> &amp; <a href="struct.Ethernet2Header.html#method.write" title="method etherparse::Ethernet2Header::write"><code>Ethernet2Header::write</code></a></li>
<li><a href="struct.SingleVlanHeader.html#method.to_bytes" title="method etherparse::SingleVlanHeader::to_bytes"><code>SingleVlanHeader::to_bytes</code></a> &amp; <a href="struct.SingleVlanHeader.html#method.write" title="method etherparse::SingleVlanHeader::write"><code>SingleVlanHeader::write</code></a></li>
<li><a href="struct.DoubleVlanHeader.html#method.to_bytes" title="method etherparse::DoubleVlanHeader::to_bytes"><code>DoubleVlanHeader::to_bytes</code></a> &amp; <a href="struct.DoubleVlanHeader.html#method.write" title="method etherparse::DoubleVlanHeader::write"><code>DoubleVlanHeader::write</code></a></li>
<li><a href="struct.Ipv4Header.html#method.to_bytes" title="method etherparse::Ipv4Header::to_bytes"><code>Ipv4Header::to_bytes</code></a> &amp; <a href="struct.Ipv4Header.html#method.write" title="method etherparse::Ipv4Header::write"><code>Ipv4Header::write</code></a> &amp; <a href="struct.Ipv4Header.html#method.write_raw" title="method etherparse::Ipv4Header::write_raw"><code>Ipv4Header::write_raw</code></a></li>
<li><a href="struct.Ipv4Extensions.html#method.write" title="method etherparse::Ipv4Extensions::write"><code>Ipv4Extensions::write</code></a></li>
<li><a href="struct.Ipv6Header.html#method.to_bytes" title="method etherparse::Ipv6Header::to_bytes"><code>Ipv6Header::to_bytes</code></a> &amp; <a href="struct.Ipv6Header.html#method.write" title="method etherparse::Ipv6Header::write"><code>Ipv6Header::write</code></a></li>
<li><a href="struct.Ipv6Extensions.html#method.write" title="method etherparse::Ipv6Extensions::write"><code>Ipv6Extensions::write</code></a></li>
<li><a href="struct.Ipv6RawExtHeader.html#method.to_bytes" title="method etherparse::Ipv6RawExtHeader::to_bytes"><code>Ipv6RawExtHeader::to_bytes</code></a> &amp; <a href="struct.Ipv6RawExtHeader.html#method.write" title="method etherparse::Ipv6RawExtHeader::write"><code>Ipv6RawExtHeader::write</code></a></li>
<li><a href="struct.IpAuthHeader.html#method.to_bytes" title="method etherparse::IpAuthHeader::to_bytes"><code>IpAuthHeader::to_bytes</code></a> &amp; <a href="struct.IpAuthHeader.html#method.write" title="method etherparse::IpAuthHeader::write"><code>IpAuthHeader::write</code></a></li>
<li><a href="struct.Ipv6FragmentHeader.html#method.to_bytes" title="method etherparse::Ipv6FragmentHeader::to_bytes"><code>Ipv6FragmentHeader::to_bytes</code></a> &amp; <a href="struct.Ipv6FragmentHeader.html#method.write" title="method etherparse::Ipv6FragmentHeader::write"><code>Ipv6FragmentHeader::write</code></a></li>
<li><a href="struct.UdpHeader.html#method.to_bytes" title="method etherparse::UdpHeader::to_bytes"><code>UdpHeader::to_bytes</code></a> &amp; <a href="struct.UdpHeader.html#method.write" title="method etherparse::UdpHeader::write"><code>UdpHeader::write</code></a></li>
<li><a href="struct.TcpHeader.html#method.to_bytes" title="method etherparse::TcpHeader::to_bytes"><code>TcpHeader::to_bytes</code></a> &amp; <a href="struct.TcpHeader.html#method.write" title="method etherparse::TcpHeader::write"><code>TcpHeader::write</code></a></li>
<li><a href="struct.Icmpv4Header.html#method.to_bytes" title="method etherparse::Icmpv4Header::to_bytes"><code>Icmpv4Header::to_bytes</code></a> &amp; <a href="struct.Icmpv4Header.html#method.write" title="method etherparse::Icmpv4Header::write"><code>Icmpv4Header::write</code></a></li>
<li><a href="struct.Icmpv6Header.html#method.to_bytes" title="method etherparse::Icmpv6Header::to_bytes"><code>Icmpv6Header::to_bytes</code></a> &amp; <a href="struct.Icmpv6Header.html#method.write" title="method etherparse::Icmpv6Header::write"><code>Icmpv6Header::write</code></a></li>
</ul>
<h2 id="references"><a class="doc-anchor" href="#references">§</a>References</h2>
<ul>
<li>Darpa Internet Program Protocol Specification <a href="https://tools.ietf.org/html/rfc791">RFC 791</a></li>
<li>Internet Protocol, Version 6 (IPv6) Specification <a href="https://tools.ietf.org/html/rfc8200">RFC 8200</a></li>
<li><a href="https://www.iana.org/assignments/ieee-802-numbers/ieee-802-numbers.xhtml">IANA 802 EtherTypes</a></li>
<li><a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">IANA Protocol Numbers</a></li>
<li><a href="https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml">Internet Protocol Version 6 (IPv6) Parameters</a></li>
<li><a href="https://en.wikipedia.org/w/index.php?title=IEEE_802.1Q&amp;oldid=820983900">Wikipedia IEEE_802.1Q</a></li>
<li>User Datagram Protocol (UDP) <a href="https://tools.ietf.org/html/rfc768">RFC 768</a></li>
<li>Transmission Control Protocol <a href="https://tools.ietf.org/html/rfc793">RFC 793</a></li>
<li>TCP Extensions for High Performance <a href="https://tools.ietf.org/html/rfc7323">RFC 7323</a></li>
<li>The Addition of Explicit Congestion Notification (ECN) to IP <a href="https://tools.ietf.org/html/rfc3168">RFC 3168</a></li>
<li>Robust Explicit Congestion Notification (ECN) Signaling with Nonces <a href="https://tools.ietf.org/html/rfc3540">RFC 3540</a></li>
<li>IP Authentication Header <a href="https://tools.ietf.org/html/rfc4302">RFC 4302</a></li>
<li>Mobility Support in IPv6 <a href="https://tools.ietf.org/html/rfc6275">RFC 6275</a></li>
<li>Host Identity Protocol Version 2 (HIPv2) <a href="https://tools.ietf.org/html/rfc7401">RFC 7401</a></li>
<li>Shim6: Level 3 Multihoming Shim Protocol for IPv6 <a href="https://tools.ietf.org/html/rfc5533">RFC 5533</a></li>
<li>Computing the Internet Checksum <a href="https://datatracker.ietf.org/doc/html/rfc1071">RFC 1071</a></li>
<li>Internet Control Message Protocol <a href="https://datatracker.ietf.org/doc/html/rfc792">RFC 792</a></li>
<li><a href="https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">IANA Internet Control Message Protocol (ICMP) Parameters</a></li>
<li>Requirements for Internet Hosts – Communication Layers <a href="https://datatracker.ietf.org/doc/html/rfc1122">RFC 1122</a></li>
<li>Requirements for IP Version 4 Routers <a href="https://datatracker.ietf.org/doc/html/rfc1812">RFC 1812</a></li>
<li>Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification <a href="https://datatracker.ietf.org/doc/html/rfc4443">RFC 4443</a></li>
<li>ICMP Router Discovery Messages <a href="https://datatracker.ietf.org/doc/html/rfc1256">RFC 1256</a></li>
<li><a href="https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml">Internet Control Message Protocol version 6 (ICMPv6) Parameters</a></li>
<li>Multicast Listener Discovery (MLD) for IPv6 <a href="https://datatracker.ietf.org/doc/html/rfc2710">RFC 2710</a></li>
<li>Neighbor Discovery for IP version 6 (IPv6) <a href="https://datatracker.ietf.org/doc/html/rfc4861">RFC 4861</a></li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="checksum/index.html" title="mod etherparse::checksum">checksum</a></dt><dd>Helpers for calculating checksums.</dd><dt><a class="mod" href="err/index.html" title="mod etherparse::err">err</a></dt><dd>Module containing error types that can be triggered.</dd><dt><a class="mod" href="ether_type/index.html" title="mod etherparse::ether_type">ether_<wbr>type</a></dt><dd>Constants for the ethertype values for easy importing (e.g. <code>use ether_type::*;</code>).</dd><dt><a class="mod" href="icmpv4/index.html" title="mod etherparse::icmpv4">icmpv4</a></dt><dd>Module containing ICMPv4 related types and constants.</dd><dt><a class="mod" href="icmpv6/index.html" title="mod etherparse::icmpv6">icmpv6</a></dt><dd>Module containing ICMPv6 related types and constants</dd><dt><a class="mod" href="io/index.html" title="mod etherparse::io">io</a></dt><dt><a class="mod" href="ip_number/index.html" title="mod etherparse::ip_number">ip_<wbr>number</a></dt><dd>Constants for the ip protocol numbers for easy importing (e.g. <code>use ip_number::*;</code>).</dd><dt><a class="mod" href="tcp_option/index.html" title="mod etherparse::tcp_option">tcp_<wbr>option</a></dt><dd>Module containing the constants for tcp options (id number &amp; sizes).</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.DoubleVlanHeader.html" title="struct etherparse::DoubleVlanHeader">Double<wbr>Vlan<wbr>Header</a></dt><dd>IEEE 802.1Q double VLAN Tagging Header</dd><dt><a class="struct" href="struct.DoubleVlanHeaderSlice.html" title="struct etherparse::DoubleVlanHeaderSlice">Double<wbr>Vlan<wbr>Header<wbr>Slice</a></dt><dd>A slice containing an double vlan header of a network package.</dd><dt><a class="struct" href="struct.DoubleVlanSlice.html" title="struct etherparse::DoubleVlanSlice">Double<wbr>Vlan<wbr>Slice</a></dt><dd>Slice containing a VLAN header &amp; payload.</dd><dt><a class="struct" href="struct.EtherPayloadSlice.html" title="struct etherparse::EtherPayloadSlice">Ether<wbr>Payload<wbr>Slice</a></dt><dd>Payload of an IP packet.</dd><dt><a class="struct" href="struct.EtherType.html" title="struct etherparse::EtherType">Ether<wbr>Type</a></dt><dd>Represents an “Ethertype” present in a Ethernet II header.</dd><dt><a class="struct" href="struct.Ethernet2Header.html" title="struct etherparse::Ethernet2Header">Ethernet2<wbr>Header</a></dt><dd>Ethernet II header.</dd><dt><a class="struct" href="struct.Ethernet2HeaderSlice.html" title="struct etherparse::Ethernet2HeaderSlice">Ethernet2<wbr>Header<wbr>Slice</a></dt><dd>A slice containing an ethernet 2 header of a network package.</dd><dt><a class="struct" href="struct.Ethernet2Slice.html" title="struct etherparse::Ethernet2Slice">Ethernet2<wbr>Slice</a></dt><dd>Slice containing an Ethernet 2 headers &amp; payload.</dd><dt><a class="struct" href="struct.IcmpEchoHeader.html" title="struct etherparse::IcmpEchoHeader">Icmp<wbr>Echo<wbr>Header</a></dt><dd>Echo Request &amp; Response common parts between ICMPv4 and ICMPv6.</dd><dt><a class="struct" href="struct.Icmpv4Header.html" title="struct etherparse::Icmpv4Header">Icmpv4<wbr>Header</a></dt><dd>A header of an ICMPv4 packet.</dd><dt><a class="struct" href="struct.Icmpv4Slice.html" title="struct etherparse::Icmpv4Slice">Icmpv4<wbr>Slice</a></dt><dd>A slice containing an ICMPv4 network package.</dd><dt><a class="struct" href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header">Icmpv6<wbr>Header</a></dt><dd>The statically sized data at the start of an ICMPv6 packet (at least the first 8 bytes of an ICMPv6 packet).</dd><dt><a class="struct" href="struct.Icmpv6Slice.html" title="struct etherparse::Icmpv6Slice">Icmpv6<wbr>Slice</a></dt><dd>A slice containing an ICMPv6 network package.</dd><dt><a class="struct" href="struct.IpAuthHeader.html" title="struct etherparse::IpAuthHeader">IpAuth<wbr>Header</a></dt><dd>IP Authentication Header (rfc4302)</dd><dt><a class="struct" href="struct.IpAuthHeaderSlice.html" title="struct etherparse::IpAuthHeaderSlice">IpAuth<wbr>Header<wbr>Slice</a></dt><dd>A slice containing an IP Authentication Header (rfc4302)</dd><dt><a class="struct" href="struct.IpFragOffset.html" title="struct etherparse::IpFragOffset">IpFrag<wbr>Offset</a></dt><dd>The fragment offset is a 13 bit unsigned integer indicating the stating
position of the payload of a packet relative to the originally fragmented
packet payload.</dd><dt><a class="struct" href="struct.IpNumber.html" title="struct etherparse::IpNumber">IpNumber</a></dt><dd>Identifiers for the next_header field in ipv6 headers and protocol field in ipv4 headers.</dd><dt><a class="struct" href="struct.IpPayloadSlice.html" title="struct etherparse::IpPayloadSlice">IpPayload<wbr>Slice</a></dt><dd>Payload of an IP packet.</dd><dt><a class="struct" href="struct.Ipv4Dscp.html" title="struct etherparse::Ipv4Dscp">Ipv4<wbr>Dscp</a></dt><dd>6 bit unsigned integer containing the “Differentiated Services
Code Point” (present in the <a href="struct.Ipv4Header.html" title="struct etherparse::Ipv4Header"><code>crate::Ipv4Header</code></a>).</dd><dt><a class="struct" href="struct.Ipv4Ecn.html" title="struct etherparse::Ipv4Ecn">Ipv4Ecn</a></dt><dd>2 bit unsigned integer containing the “Explicit Congestion
Notification” (present in the <a href="struct.Ipv4Header.html" title="struct etherparse::Ipv4Header"><code>crate::Ipv4Header</code></a>).</dd><dt><a class="struct" href="struct.Ipv4Extensions.html" title="struct etherparse::Ipv4Extensions">Ipv4<wbr>Extensions</a></dt><dd>IPv4 extension headers present after the ip header.</dd><dt><a class="struct" href="struct.Ipv4ExtensionsSlice.html" title="struct etherparse::Ipv4ExtensionsSlice">Ipv4<wbr>Extensions<wbr>Slice</a></dt><dd>Slices of the IPv4 extension headers present after the ip header.</dd><dt><a class="struct" href="struct.Ipv4Header.html" title="struct etherparse::Ipv4Header">Ipv4<wbr>Header</a></dt><dd>IPv4 header with options.</dd><dt><a class="struct" href="struct.Ipv4HeaderSlice.html" title="struct etherparse::Ipv4HeaderSlice">Ipv4<wbr>Header<wbr>Slice</a></dt><dd>A slice containing an ipv4 header of a network package.</dd><dt><a class="struct" href="struct.Ipv4Options.html" title="struct etherparse::Ipv4Options">Ipv4<wbr>Options</a></dt><dd>Options present in an <a href="struct.Ipv4Header.html" title="struct etherparse::Ipv4Header"><code>crate::Ipv4Header</code></a>.</dd><dt><a class="struct" href="struct.Ipv4Slice.html" title="struct etherparse::Ipv4Slice">Ipv4<wbr>Slice</a></dt><dd>Slice containing the IPv4 headers &amp; payload.</dd><dt><a class="struct" href="struct.Ipv6ExtensionSliceIter.html" title="struct etherparse::Ipv6ExtensionSliceIter">Ipv6<wbr>Extension<wbr>Slice<wbr>Iter</a></dt><dd>Allows iterating over the IPv6 extension headers present in an <a href="struct.Ipv6ExtensionsSlice.html" title="struct etherparse::Ipv6ExtensionsSlice">Ipv6ExtensionsSlice</a>.</dd><dt><a class="struct" href="struct.Ipv6Extensions.html" title="struct etherparse::Ipv6Extensions">Ipv6<wbr>Extensions</a></dt><dd>IPv6 extension headers present after the ip header.</dd><dt><a class="struct" href="struct.Ipv6ExtensionsSlice.html" title="struct etherparse::Ipv6ExtensionsSlice">Ipv6<wbr>Extensions<wbr>Slice</a></dt><dd>Slice containing the IPv6 extension headers present after the ip header.</dd><dt><a class="struct" href="struct.Ipv6FlowLabel.html" title="struct etherparse::Ipv6FlowLabel">Ipv6<wbr>Flow<wbr>Label</a></dt><dd>The IPv6 “Flow Label” is a 20 bit unsigned integer present in
the <a href="struct.Ipv6Header.html" title="struct etherparse::Ipv6Header"><code>crate::Ipv6Header</code></a>.</dd><dt><a class="struct" href="struct.Ipv6FragmentHeader.html" title="struct etherparse::Ipv6FragmentHeader">Ipv6<wbr>Fragment<wbr>Header</a></dt><dd>IPv6 fragment header.</dd><dt><a class="struct" href="struct.Ipv6FragmentHeaderSlice.html" title="struct etherparse::Ipv6FragmentHeaderSlice">Ipv6<wbr>Fragment<wbr>Header<wbr>Slice</a></dt><dd>Slice containing an IPv6 fragment header.</dd><dt><a class="struct" href="struct.Ipv6Header.html" title="struct etherparse::Ipv6Header">Ipv6<wbr>Header</a></dt><dd>IPv6 header according to rfc8200.</dd><dt><a class="struct" href="struct.Ipv6HeaderSlice.html" title="struct etherparse::Ipv6HeaderSlice">Ipv6<wbr>Header<wbr>Slice</a></dt><dd>A slice containing an ipv6 header of a network package.</dd><dt><a class="struct" href="struct.Ipv6RawExtHeader.html" title="struct etherparse::Ipv6RawExtHeader">Ipv6<wbr>RawExt<wbr>Header</a></dt><dd>Raw IPv6 extension header (undecoded payload).</dd><dt><a class="struct" href="struct.Ipv6RawExtHeaderSlice.html" title="struct etherparse::Ipv6RawExtHeaderSlice">Ipv6<wbr>RawExt<wbr>Header<wbr>Slice</a></dt><dd>Slice containing an IPv6 extension header without specific decoding methods (fallback in case no specific implementation is available).</dd><dt><a class="struct" href="struct.Ipv6RoutingExtensions.html" title="struct etherparse::Ipv6RoutingExtensions">Ipv6<wbr>Routing<wbr>Extensions</a></dt><dd>In case a route header is present it is also possible
to attach a “final destination” header.</dd><dt><a class="struct" href="struct.Ipv6Slice.html" title="struct etherparse::Ipv6Slice">Ipv6<wbr>Slice</a></dt><dd>Slice containing the IPv6 headers &amp; payload.</dd><dt><a class="struct" href="struct.LaxIpPayloadSlice.html" title="struct etherparse::LaxIpPayloadSlice">LaxIp<wbr>Payload<wbr>Slice</a></dt><dd>Laxly identified payload of an IP packet (potentially incomplete).</dd><dt><a class="struct" href="struct.LaxIpv4Slice.html" title="struct etherparse::LaxIpv4Slice">LaxIpv4<wbr>Slice</a></dt><dd>Slice containing laxly separated IPv4 headers &amp; payload.</dd><dt><a class="struct" href="struct.LaxIpv6Slice.html" title="struct etherparse::LaxIpv6Slice">LaxIpv6<wbr>Slice</a></dt><dd>Slice containing laxly separated IPv6 headers &amp; payload.</dd><dt><a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacket<wbr>Headers</a></dt><dd>Decoded packet headers (data link layer and lower) with lax length checks.</dd><dt><a class="struct" href="struct.LaxSlicedPacket.html" title="struct etherparse::LaxSlicedPacket">LaxSliced<wbr>Packet</a></dt><dd>Packet slice split into multiple slices containing
the different headers &amp; payload.</dd><dt><a class="struct" href="struct.PacketBuilder.html" title="struct etherparse::PacketBuilder">Packet<wbr>Builder</a></dt><dd>Helper for building packets.</dd><dt><a class="struct" href="struct.PacketBuilderStep.html" title="struct etherparse::PacketBuilderStep">Packet<wbr>Builder<wbr>Step</a></dt><dd>An unfinished packet that is build with the packet builder</dd><dt><a class="struct" href="struct.PacketHeaders.html" title="struct etherparse::PacketHeaders">Packet<wbr>Headers</a></dt><dd>Decoded packet headers (data link layer and lower).</dd><dt><a class="struct" href="struct.SingleVlanHeader.html" title="struct etherparse::SingleVlanHeader">Single<wbr>Vlan<wbr>Header</a></dt><dd>IEEE 802.1Q VLAN Tagging Header</dd><dt><a class="struct" href="struct.SingleVlanHeaderSlice.html" title="struct etherparse::SingleVlanHeaderSlice">Single<wbr>Vlan<wbr>Header<wbr>Slice</a></dt><dd>A slice containing a single vlan header of a network package.</dd><dt><a class="struct" href="struct.SingleVlanSlice.html" title="struct etherparse::SingleVlanSlice">Single<wbr>Vlan<wbr>Slice</a></dt><dd>Slice containing a VLAN header &amp; payload.</dd><dt><a class="struct" href="struct.SlicedPacket.html" title="struct etherparse::SlicedPacket">Sliced<wbr>Packet</a></dt><dd>Packet slice split into multiple slices containing the different headers &amp; payload.</dd><dt><a class="struct" href="struct.TcpHeader.html" title="struct etherparse::TcpHeader">TcpHeader</a></dt><dd>TCP header according to rfc 793.</dd><dt><a class="struct" href="struct.TcpHeaderSlice.html" title="struct etherparse::TcpHeaderSlice">TcpHeader<wbr>Slice</a></dt><dd>A slice containing an tcp header of a network package.</dd><dt><a class="struct" href="struct.TcpOptions.html" title="struct etherparse::TcpOptions">TcpOptions</a></dt><dd>Options present in a TCP header.</dd><dt><a class="struct" href="struct.TcpOptionsIterator.html" title="struct etherparse::TcpOptionsIterator">TcpOptions<wbr>Iterator</a></dt><dd>Allows iterating over the options after a TCP header.</dd><dt><a class="struct" href="struct.TcpSlice.html" title="struct etherparse::TcpSlice">TcpSlice</a></dt><dd>Slice containing the TCP header &amp; payload.</dd><dt><a class="struct" href="struct.UdpHeader.html" title="struct etherparse::UdpHeader">UdpHeader</a></dt><dd>Udp header according to rfc768.</dd><dt><a class="struct" href="struct.UdpHeaderSlice.html" title="struct etherparse::UdpHeaderSlice">UdpHeader<wbr>Slice</a></dt><dd>A slice containing an udp header of a network package. Struct allows the selective read of fields in the header.</dd><dt><a class="struct" href="struct.UdpSlice.html" title="struct etherparse::UdpSlice">UdpSlice</a></dt><dd>Slice containing the UDP headers &amp; payload.</dd><dt><a class="struct" href="struct.VlanId.html" title="struct etherparse::VlanId">VlanId</a></dt><dd>12 bit unsigned integer containing the “VLAN identifier” (present
in the <a href="struct.SingleVlanHeader.html" title="struct etherparse::SingleVlanHeader"><code>crate::SingleVlanHeader</code></a>).</dd><dt><a class="struct" href="struct.VlanPcp.html" title="struct etherparse::VlanPcp">VlanPcp</a></dt><dd>3 bit unsigned integer containing the “Priority Code Point”
(present in the <a href="struct.SingleVlanHeader.html" title="struct etherparse::SingleVlanHeader"><code>crate::SingleVlanHeader</code></a>).</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Icmpv4Type.html" title="enum etherparse::Icmpv4Type">Icmpv4<wbr>Type</a></dt><dd>Starting contents of an ICMPv4 packet without the checksum.</dd><dt><a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6<wbr>Type</a></dt><dd>Different kinds of ICMPv6 messages.</dd><dt><a class="enum" href="enum.InternetSlice.html" title="enum etherparse::InternetSlice">Internet<wbr>Slice</a></dt><dd>Deprecated use <a href="enum.InternetSlice.html" title="enum etherparse::InternetSlice"><code>crate::NetSlice</code></a> or <a href="enum.IpSlice.html" title="enum etherparse::IpSlice"><code>crate::IpSlice</code></a> instead.
Slice containing the network headers &amp; payloads (e.g. IPv4, IPv6, ARP).</dd><dt><a class="enum" href="enum.IpHeaders.html" title="enum etherparse::IpHeaders">IpHeaders</a></dt><dd>Internet protocol headers version 4 &amp; 6.</dd><dt><a class="enum" href="enum.IpSlice.html" title="enum etherparse::IpSlice">IpSlice</a></dt><dd>Slice containing the IP header (v4 or v6), extension headers &amp;
payload.</dd><dt><a class="enum" href="enum.Ipv6ExtensionSlice.html" title="enum etherparse::Ipv6ExtensionSlice">Ipv6<wbr>Extension<wbr>Slice</a></dt><dd>Enum containing a slice of a supported ipv6 extension header.</dd><dt><a class="enum" href="enum.LaxIpSlice.html" title="enum etherparse::LaxIpSlice">LaxIp<wbr>Slice</a></dt><dd>Slice containing laxly separated IPv4 or IPv6 headers &amp; payload.</dd><dt><a class="enum" href="enum.LaxNetSlice.html" title="enum etherparse::LaxNetSlice">LaxNet<wbr>Slice</a></dt><dd>Slice containing laxly parsed the network headers &amp; payloads (e.g. IPv4, IPv6, ARP).</dd><dt><a class="enum" href="enum.LaxPayloadSlice.html" title="enum etherparse::LaxPayloadSlice">LaxPayload<wbr>Slice</a></dt><dd>Laxly parsed payload together with an identifier the type of content &amp; the
information if the payload is incomplete.</dd><dt><a class="enum" href="enum.LenSource.html" title="enum etherparse::LenSource">LenSource</a></dt><dd>Sources of length limiting values (e.g. “ipv6 payload length field”).</dd><dt><a class="enum" href="enum.LinkSlice.html" title="enum etherparse::LinkSlice">Link<wbr>Slice</a></dt><dd>A slice containing the link layer header (currently only Ethernet II is supported).</dd><dt><a class="enum" href="enum.NetHeaders.html" title="enum etherparse::NetHeaders">NetHeaders</a></dt><dd>Headers on the network layer (e.g. IP, ARP, …).</dd><dt><a class="enum" href="enum.NetSlice.html" title="enum etherparse::NetSlice">NetSlice</a></dt><dd>Slice containing the network headers &amp; payloads (e.g. IPv4, IPv6, ARP).</dd><dt><a class="enum" href="enum.PayloadSlice.html" title="enum etherparse::PayloadSlice">Payload<wbr>Slice</a></dt><dd>Payload together with an identifier the type of content.</dd><dt><a class="enum" href="enum.TcpOptionElement.html" title="enum etherparse::TcpOptionElement">TcpOption<wbr>Element</a></dt><dd>Different kinds of options that can be present in the options part of a tcp header.</dd><dt><a class="enum" href="enum.TcpOptionReadError.html" title="enum etherparse::TcpOptionReadError">TcpOption<wbr>Read<wbr>Error</a></dt><dd>Errors that can occour while reading the options of a TCP header.</dd><dt><a class="enum" href="enum.TcpOptionWriteError.html" title="enum etherparse::TcpOptionWriteError">TcpOption<wbr>Write<wbr>Error</a></dt><dd>Errors that can occour when setting the options of a tcp header.</dd><dt><a class="enum" href="enum.TransportHeader.html" title="enum etherparse::TransportHeader">Transport<wbr>Header</a></dt><dd>The possible headers on the transport layer</dd><dt><a class="enum" href="enum.TransportSlice.html" title="enum etherparse::TransportSlice">Transport<wbr>Slice</a></dt><dt><a class="enum" href="enum.VlanHeader.html" title="enum etherparse::VlanHeader">Vlan<wbr>Header</a></dt><dd>IEEE 802.1Q VLAN Tagging Header (can be single or double tagged).</dd><dt><a class="enum" href="enum.VlanSlice.html" title="enum etherparse::VlanSlice">Vlan<wbr>Slice</a></dt><dd>A slice containing a single or double vlan header.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.TCP_MAXIMUM_DATA_OFFSET.html" title="constant etherparse::TCP_MAXIMUM_DATA_OFFSET">TCP_<wbr>MAXIMUM_<wbr>DATA_<wbr>OFFSET</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="struct.TcpHeader.html#associatedconstant.MAX_DATA_OFFSET" title="associated constant etherparse::TcpHeader::MAX_DATA_OFFSET"><code>TcpHeader::MAX_DATA_OFFSET</code></a> instead.</dd><dt><a class="constant" href="constant.TCP_MINIMUM_DATA_OFFSET.html" title="constant etherparse::TCP_MINIMUM_DATA_OFFSET">TCP_<wbr>MINIMUM_<wbr>DATA_<wbr>OFFSET</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="struct.TcpHeader.html#associatedconstant.MIN_DATA_OFFSET" title="associated constant etherparse::TcpHeader::MIN_DATA_OFFSET"><code>TcpHeader::MIN_DATA_OFFSET</code></a> instead.</dd><dt><a class="constant" href="constant.TCP_MINIMUM_HEADER_SIZE.html" title="constant etherparse::TCP_MINIMUM_HEADER_SIZE">TCP_<wbr>MINIMUM_<wbr>HEADER_<wbr>SIZE</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="struct.TcpHeader.html#associatedconstant.MIN_LEN" title="associated constant etherparse::TcpHeader::MIN_LEN"><code>TcpHeader::MIN_LEN</code></a> instead.</dd><dt><a class="constant" href="constant.TCP_OPTION_ID_END.html" title="constant etherparse::TCP_OPTION_ID_END">TCP_<wbr>OPTION_<wbr>ID_<wbr>END</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated please use <a href="tcp_option/constant.KIND_END.html" title="constant etherparse::tcp_option::KIND_END">tcp_option::KIND_END</a> instead.</dd><dt><a class="constant" href="constant.TCP_OPTION_ID_MAXIMUM_SEGMENT_SIZE.html" title="constant etherparse::TCP_OPTION_ID_MAXIMUM_SEGMENT_SIZE">TCP_<wbr>OPTION_<wbr>ID_<wbr>MAXIMUM_<wbr>SEGMENT_<wbr>SIZE</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated please use <a href="tcp_option/constant.KIND_MAXIMUM_SEGMENT_SIZE.html" title="constant etherparse::tcp_option::KIND_MAXIMUM_SEGMENT_SIZE">tcp_option::KIND_MAXIMUM_SEGMENT_SIZE</a> instead.</dd><dt><a class="constant" href="constant.TCP_OPTION_ID_NOP.html" title="constant etherparse::TCP_OPTION_ID_NOP">TCP_<wbr>OPTION_<wbr>ID_<wbr>NOP</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated please use <a href="tcp_option/constant.KIND_NOOP.html" title="constant etherparse::tcp_option::KIND_NOOP">tcp_option::KIND_NOOP</a> instead.</dd><dt><a class="constant" href="constant.TCP_OPTION_ID_SELECTIVE_ACK.html" title="constant etherparse::TCP_OPTION_ID_SELECTIVE_ACK">TCP_<wbr>OPTION_<wbr>ID_<wbr>SELECTIVE_<wbr>ACK</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated please use <a href="tcp_option/constant.KIND_SELECTIVE_ACK.html" title="constant etherparse::tcp_option::KIND_SELECTIVE_ACK">tcp_option::KIND_SELECTIVE_ACK</a> instead.</dd><dt><a class="constant" href="constant.TCP_OPTION_ID_SELECTIVE_ACK_PERMITTED.html" title="constant etherparse::TCP_OPTION_ID_SELECTIVE_ACK_PERMITTED">TCP_<wbr>OPTION_<wbr>ID_<wbr>SELECTIVE_<wbr>ACK_<wbr>PERMITTED</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated please use <a href="tcp_option/constant.KIND_SELECTIVE_ACK_PERMITTED.html" title="constant etherparse::tcp_option::KIND_SELECTIVE_ACK_PERMITTED">tcp_option::KIND_SELECTIVE_ACK_PERMITTED</a> instead.</dd><dt><a class="constant" href="constant.TCP_OPTION_ID_TIMESTAMP.html" title="constant etherparse::TCP_OPTION_ID_TIMESTAMP">TCP_<wbr>OPTION_<wbr>ID_<wbr>TIMESTAMP</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated please use <a href="tcp_option/constant.KIND_TIMESTAMP.html" title="constant etherparse::tcp_option::KIND_TIMESTAMP">tcp_option::KIND_TIMESTAMP</a> instead.</dd><dt><a class="constant" href="constant.TCP_OPTION_ID_WINDOW_SCALE.html" title="constant etherparse::TCP_OPTION_ID_WINDOW_SCALE">TCP_<wbr>OPTION_<wbr>ID_<wbr>WINDOW_<wbr>SCALE</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated please use <a href="tcp_option/constant.KIND_WINDOW_SCALE.html" title="constant etherparse::tcp_option::KIND_WINDOW_SCALE">tcp_option::KIND_WINDOW_SCALE</a> instead.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.ErrorField.html" title="type etherparse::ErrorField">Error<wbr>Field</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="err/enum.ReadError.html" title="enum etherparse::err::ReadError">err::ReadError</a> instead or use the specific error type returned by operation you are using.</dd><dt><a class="type" href="type.IPv6AuthenticationHeader.html" title="type etherparse::IPv6AuthenticationHeader">IPv6<wbr>Authentication<wbr>Header</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="struct.IpAuthHeader.html" title="struct etherparse::IpAuthHeader">IpAuthHeader</a> instead.</dd><dt><a class="type" href="type.IpAuthenticationHeader.html" title="type etherparse::IpAuthenticationHeader">IpAuthentication<wbr>Header</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="struct.IpAuthHeader.html" title="struct etherparse::IpAuthHeader">IpAuthHeader</a> instead.</dd><dt><a class="type" href="type.IpAuthenticationHeaderSlice.html" title="type etherparse::IpAuthenticationHeaderSlice">IpAuthentication<wbr>Header<wbr>Slice</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="struct.IpAuthHeaderSlice.html" title="struct etherparse::IpAuthHeaderSlice">IpAuthHeaderSlice</a> instead.</dd><dt><a class="type" href="type.IpHeader.html" title="type etherparse::IpHeader">IpHeader</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="enum.NetHeaders.html" title="enum etherparse::NetHeaders"><code>crate::NetHeaders</code></a> instead.</dd><dt><a class="type" href="type.IpTrafficClass.html" title="type etherparse::IpTrafficClass">IpTraffic<wbr>Class</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>This type has been deprecated please use <a href="struct.IpNumber.html" title="struct etherparse::IpNumber">IpNumber</a> instead.</dd><dt><a class="type" href="type.Ipv6RawExtensionHeader.html" title="type etherparse::Ipv6RawExtensionHeader">Ipv6<wbr>RawExtension<wbr>Header</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated. Use <a href="struct.Ipv6RawExtHeader.html" title="struct etherparse::Ipv6RawExtHeader">Ipv6RawExtHeader</a> instead.</dd><dt><a class="type" href="type.Ipv6RawExtensionHeaderSlice.html" title="type etherparse::Ipv6RawExtensionHeaderSlice">Ipv6<wbr>RawExtension<wbr>Header<wbr>Slice</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated. Use <a href="struct.Ipv6RawExtHeaderSlice.html" title="struct etherparse::Ipv6RawExtHeaderSlice">Ipv6RawExtHeaderSlice</a> instead.</dd><dt><a class="type" href="type.ReadError.html" title="type etherparse::ReadError">Read<wbr>Error</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Deprecated use <a href="err/enum.ReadError.html" title="enum etherparse::err::ReadError">err::ReadError</a> instead or use the specific error type returned by operation you are using.</dd></dl><script type="text/json" id="notable-traits-data">{"&'a [u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.87.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.87.0/std/primitive.u8.html\">u8</a>]</div>","&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.87.0/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.87.0/std/primitive.u8.html\">u8</a>]</div>"}</script></section></div></main></body></html>