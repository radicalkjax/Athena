<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Different kinds of ICMPv6 messages."><title>Icmpv6Type in etherparse - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="etherparse" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../etherparse/index.html">etherparse</a><span class="version">0.14.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Icmpv6<wbr>Type</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#decoding-example-complete-packet" title="Decoding Example (complete packet):">Decoding Example (complete packet):</a></li><li><a href="#encoding-example-only-icmpv6-part" title="Encoding Example (only ICMPv6 part)">Encoding Example (only ICMPv6 part)</a></li></ul><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.DestinationUnreachable" title="DestinationUnreachable">DestinationUnreachable</a></li><li><a href="#variant.EchoReply" title="EchoReply">EchoReply</a></li><li><a href="#variant.EchoRequest" title="EchoRequest">EchoRequest</a></li><li><a href="#variant.PacketTooBig" title="PacketTooBig">PacketTooBig</a></li><li><a href="#variant.ParameterProblem" title="ParameterProblem">ParameterProblem</a></li><li><a href="#variant.TimeExceeded" title="TimeExceeded">TimeExceeded</a></li><li><a href="#variant.Unknown" title="Unknown">Unknown</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.calc_checksum" title="calc_checksum">calc_checksum</a></li><li><a href="#method.code_u8" title="code_u8">code_u8</a></li><li><a href="#method.fixed_payload_size" title="fixed_payload_size">fixed_payload_size</a></li><li><a href="#method.header_len" title="header_len">header_len</a></li><li><a href="#method.to_header" title="to_header">to_header</a></li><li><a href="#method.type_u8" title="type_u8">type_u8</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Icmpv6Type" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Icmpv6Type" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Icmpv6Type" title="Debug">Debug</a></li><li><a href="#impl-Eq-for-Icmpv6Type" title="Eq">Eq</a></li><li><a href="#impl-PartialEq-for-Icmpv6Type" title="PartialEq">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-Icmpv6Type" title="StructuralPartialEq">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Icmpv6Type" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Icmpv6Type" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Icmpv6Type" title="Send">Send</a></li><li><a href="#impl-Sync-for-Icmpv6Type" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Icmpv6Type" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Icmpv6Type" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate etherparse</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">etherparse</a></div><h1>Enum <span class="enum">Icmpv6Type</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/etherparse/transport/icmpv6_type.rs.html#88-332">Source</a> </span></div><pre class="rust item-decl"><code>pub enum Icmpv6Type {
    Unknown {
        type_u8: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>,
        code_u8: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>,
        bytes5to8: [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.array.html">4</a>],
    },
    DestinationUnreachable(<a class="enum" href="icmpv6/enum.DestUnreachableCode.html" title="enum etherparse::icmpv6::DestUnreachableCode">DestUnreachableCode</a>),
    PacketTooBig {
        mtu: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u32.html">u32</a>,
    },
    TimeExceeded(<a class="enum" href="icmpv6/enum.TimeExceededCode.html" title="enum etherparse::icmpv6::TimeExceededCode">TimeExceededCode</a>),
    ParameterProblem(<a class="struct" href="icmpv6/struct.ParameterProblemHeader.html" title="struct etherparse::icmpv6::ParameterProblemHeader">ParameterProblemHeader</a>),
    EchoRequest(<a class="struct" href="struct.IcmpEchoHeader.html" title="struct etherparse::IcmpEchoHeader">IcmpEchoHeader</a>),
    EchoReply(<a class="struct" href="struct.IcmpEchoHeader.html" title="struct etherparse::IcmpEchoHeader">IcmpEchoHeader</a>),
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Different kinds of ICMPv6 messages.</p>
<p>The data stored in this enum corresponds to the statically sized data
at the start of an ICMPv6 packet without the checksum. If you also need
the checksum you can package and <a href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type"><code>Icmpv6Type</code></a> value in an <a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a>
struct.</p>
<h2 id="decoding-example-complete-packet"><a class="doc-anchor" href="#decoding-example-complete-packet">§</a>Decoding Example (complete packet):</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>etherparse::PacketHeaders;

<span class="kw">let </span>headers = PacketHeaders::from_ethernet_slice(<span class="kw-2">&amp;</span>packet).unwrap();

<span class="kw">use </span>etherparse::TransportHeader::<span class="kw-2">*</span>;
<span class="kw">match </span>headers.transport {
    <span class="prelude-val">Some</span>(Icmpv6(icmp)) =&gt; {
        <span class="kw">use </span>etherparse::Icmpv6Type::<span class="kw-2">*</span>;
        <span class="kw">match </span>icmp.icmp_type {
            <span class="comment">// Unknown is used when further decoding is currently not supported for the icmp type &amp; code.
            // You can still further decode the packet on your own by using the raw data in this enum
            // together with `headers.payload` (contains the packet data after the 8th byte)
            </span>Unknown{ type_u8, code_u8, bytes5to8 } =&gt; <span class="macro">println!</span>(<span class="string">"Unknown{{ type_u8: {}, code_u8: {}, bytes5to8: {:?} }}"</span>, type_u8, code_u8, bytes5to8),
            DestinationUnreachable(header) =&gt; <span class="macro">println!</span>(<span class="string">"{:?}"</span>, header),
            PacketTooBig { mtu } =&gt; <span class="macro">println!</span>(<span class="string">"TimeExceeded{{ mtu: {} }}"</span>, mtu),
            TimeExceeded(code) =&gt; <span class="macro">println!</span>(<span class="string">"{:?}"</span>, code),
            ParameterProblem(header) =&gt; <span class="macro">println!</span>(<span class="string">"{:?}"</span>, header),
            EchoRequest(header) =&gt; <span class="macro">println!</span>(<span class="string">"{:?}"</span>, header),
            EchoReply(header) =&gt; <span class="macro">println!</span>(<span class="string">"{:?}"</span>, header),
        }
    },
    <span class="kw">_ </span>=&gt; {},
}</code></pre></div>
<h2 id="encoding-example-only-icmpv6-part"><a class="doc-anchor" href="#encoding-example-only-icmpv6-part">§</a>Encoding Example (only ICMPv6 part)</h2>
<p>To get the on wire bytes of an Icmpv6Type it needs to get packaged
into a <a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a> so the checksum gets calculated.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">use </span>etherparse::{Icmpv6Type, icmpv6::DestUnreachableCode};
<span class="kw">let </span>t = Icmpv6Type::DestinationUnreachable(
    DestUnreachableCode::Address
);

<span class="comment">// to calculate the checksum the ip header and the payload
// (in case of dest unreachable the invoking packet) are needed
</span><span class="kw">let </span>header = t.to_header(ip_header.source, ip_header.destination, <span class="kw-2">&amp;</span>invoking_packet).unwrap();

<span class="comment">// an ICMPv6 packet is composed of the header and payload
</span><span class="kw">let </span><span class="kw-2">mut </span>packet = Vec::with_capacity(header.header_len() + invoking_packet.len());
packet.extend_from_slice(<span class="kw-2">&amp;</span>header.to_bytes());
packet.extend_from_slice(<span class="kw-2">&amp;</span>invoking_packet);</code></pre></div>
</div></details><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.Unknown" class="variant"><a href="#variant.Unknown" class="anchor">§</a><h3 class="code-header">Unknown</h3></section><div class="docblock"><p>In case of an unknown icmp type is received the header elements of
the first 8 bytes/octets are stored raw in this enum value.</p>
<h4 id="what-is-part-of-the-header-for-icmpv6typeunknown"><a class="doc-anchor" href="#what-is-part-of-the-header-for-icmpv6typeunknown">§</a>What is part of the header for <code>Icmpv6Type::Unknown</code>?</h4>
<p>For unknown ICMPv6 type &amp; code combination the first 8 bytes are stored
in the <a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a> and the rest is stored in the payload
(<a href="struct.Icmpv6Slice.html#method.payload" title="method etherparse::Icmpv6Slice::payload"><code>Icmpv6Slice::payload</code></a> or <a href="struct.PacketHeaders.html#structfield.payload" title="field etherparse::PacketHeaders::payload"><code>PacketHeaders::payload</code></a>).</p>
<div class="example-wrap"><pre class="language-text"><code>0               1               2               3               4
+---------------------------------------------------------------+  -
|     type_u8   |    code_u8    |  checksum (in Icmpv6Header)   |  |
+---------------------------------------------------------------+  | part of header &amp; type
|                          bytes5to8                            |  ↓
+---------------------------------------------------------------+  -
|                                                               |  |
...                           ...                             ...  | part of payload
|                                                               |  ↓
+---------------------------------------------------------------+  -</code></pre></div></div><div class="sub-variant" id="variant.Unknown.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Unknown.field.type_u8" class="section-header"><a href="#variant.Unknown.field.type_u8" class="anchor field">§</a><code>type_u8: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a></code></span><div class="docblock"><p>ICMPv6 type (present in the first byte of the ICMPv6 packet).</p>
</div></div><div class="sub-variant-field"><span id="variant.Unknown.field.code_u8" class="section-header"><a href="#variant.Unknown.field.code_u8" class="anchor field">§</a><code>code_u8: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a></code></span><div class="docblock"><p>ICMPv6 code (present in the 2nd byte of the ICMPv6 packet).</p>
</div></div><div class="sub-variant-field"><span id="variant.Unknown.field.bytes5to8" class="section-header"><a href="#variant.Unknown.field.bytes5to8" class="anchor field">§</a><code>bytes5to8: [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.array.html">4</a>]</code></span><div class="docblock"><p>Bytes located at th 5th, 6th, 7th and 8th position of the ICMP packet.</p>
</div></div></div><section id="variant.DestinationUnreachable" class="variant"><a href="#variant.DestinationUnreachable" class="anchor">§</a><h3 class="code-header">DestinationUnreachable(<a class="enum" href="icmpv6/enum.DestUnreachableCode.html" title="enum etherparse::icmpv6::DestUnreachableCode">DestUnreachableCode</a>)</h3></section><div class="docblock"><p>Message sent to inform the client that the destination is unreachable for
some reason.</p>
<h4 id="what-is-part-of-the-header-for-icmpv6typedestinationunreachable"><a class="doc-anchor" href="#what-is-part-of-the-header-for-icmpv6typedestinationunreachable">§</a>What is part of the header for <code>Icmpv6Type::DestinationUnreachable</code>?</h4>
<p>For the <code>Icmpv6Type::DestinationUnreachable</code> type the first 8 bytes/octets of the ICMPv6
packet are part of the header. The <code>unused</code> part is not stored and droped.
The offending packet is stored in the payload part of the packet
(<a href="struct.Icmpv6Slice.html#method.payload" title="method etherparse::Icmpv6Slice::payload"><code>Icmpv6Slice::payload</code></a> &amp; <a href="struct.PacketHeaders.html#structfield.payload" title="field etherparse::PacketHeaders::payload"><code>PacketHeaders::payload</code></a>) and is not part of
the <a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a>.</p>
<div class="example-wrap"><pre class="language-text"><code>0               1               2               3               4
+---------------------------------------------------------------+  -
|       1       | [value as u8] |  checksum (in Icmpv6Header)   |  |
+---------------------------------------------------------------+  | part of header &amp; type
|                           &lt;unused&gt;                            |  ↓
+---------------------------------------------------------------+  -
|                                                               |  |
|     &lt;As much of invoking packet as possible without           |  | part of payload
...   the ICMPv6 packet exceeding the minimum IPv6 MTU&gt;       ...  |
|                                                               |  ↓
+---------------------------------------------------------------+  -</code></pre></div><h4 id="rfc-4443-description"><a class="doc-anchor" href="#rfc-4443-description">§</a>RFC 4443 Description</h4>
<p>A Destination Unreachable message SHOULD be generated by a router, or
by the IPv6 layer in the originating node, in response to a packet
that cannot be delivered to its destination address for reasons other
than congestion.  (An ICMPv6 message MUST NOT be generated if a
packet is dropped due to congestion.)</p>
</div><section id="variant.PacketTooBig" class="variant"><a href="#variant.PacketTooBig" class="anchor">§</a><h3 class="code-header">PacketTooBig</h3></section><div class="docblock"><p>Sent if a packet to too big to be forwarded.</p>
<h4 id="what-is-part-of-the-header-for-icmpv6typepackettoobig"><a class="doc-anchor" href="#what-is-part-of-the-header-for-icmpv6typepackettoobig">§</a>What is part of the header for <code>Icmpv6Type::PacketTooBig</code>?</h4>
<p>For the <code>Icmpv6Type::PacketTooBig</code> type the first 8 bytes/octets of the ICMPv6
packet are part of the header. The offending packet is stored in the payload part of the packet
(<a href="struct.Icmpv6Slice.html#method.payload" title="method etherparse::Icmpv6Slice::payload"><code>Icmpv6Slice::payload</code></a> &amp; <a href="struct.PacketHeaders.html#structfield.payload" title="field etherparse::PacketHeaders::payload"><code>PacketHeaders::payload</code></a>) and is not part of
the <a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a>.</p>
<div class="example-wrap"><pre class="language-text"><code>0               1               2               3               4
+---------------------------------------------------------------+  -
|       2       |       0       |  checksum (in Icmpv6Header)   |  |
+---------------------------------------------------------------+  | part of header &amp; type
|                              mtu                              |  ↓
+---------------------------------------------------------------+  -
|                                                               |  |
|     &lt;As much of invoking packet as possible without           |  | part of payload
...   the ICMPv6 packet exceeding the minimum IPv6 MTU&gt;       ...  |
|                                                               |  ↓
+---------------------------------------------------------------+  -</code></pre></div><h4 id="rfc-4443-description-1"><a class="doc-anchor" href="#rfc-4443-description-1">§</a>RFC 4443 Description</h4>
<p>A Packet Too Big MUST be sent by a router in response to a packet
that it cannot forward because the packet is larger than the MTU of
the outgoing link.  The information in this message is used as part
of the Path MTU Discovery process.</p>
</div><div class="sub-variant" id="variant.PacketTooBig.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.PacketTooBig.field.mtu" class="section-header"><a href="#variant.PacketTooBig.field.mtu" class="anchor field">§</a><code>mtu: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u32.html">u32</a></code></span><div class="docblock"><p>The Maximum Transmission Unit of the next-hop link.</p>
</div></div></div><section id="variant.TimeExceeded" class="variant"><a href="#variant.TimeExceeded" class="anchor">§</a><h3 class="code-header">TimeExceeded(<a class="enum" href="icmpv6/enum.TimeExceededCode.html" title="enum etherparse::icmpv6::TimeExceededCode">TimeExceededCode</a>)</h3></section><div class="docblock"><p>Generated when a datagram had to be discarded due to the hop limit field
reaching zero.</p>
<h4 id="what-is-part-of-the-header-for-icmpv6typetimeexceeded"><a class="doc-anchor" href="#what-is-part-of-the-header-for-icmpv6typetimeexceeded">§</a>What is part of the header for <code>Icmpv6Type::TimeExceeded</code>?</h4>
<p>For the <code>Icmpv6Type::TimeExceeded</code> type the first 8 bytes/octets of the ICMPv6
packet are part of the header. The <code>unused</code> part is not stored and droped.
The offending packet is stored in the payload part of the packet
(<a href="struct.Icmpv6Slice.html#method.payload" title="method etherparse::Icmpv6Slice::payload"><code>Icmpv6Slice::payload</code></a> &amp; <a href="struct.PacketHeaders.html#structfield.payload" title="field etherparse::PacketHeaders::payload"><code>PacketHeaders::payload</code></a>) and is not part of
the <a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a>.</p>
<div class="example-wrap"><pre class="language-text"><code>0               1               2               3               4
+---------------------------------------------------------------+  -
|       3       | [value as u8] |  checksum (in Icmpv6Header)   |  |
+---------------------------------------------------------------+  | part of header &amp; type
|                           &lt;unused&gt;                            |  ↓
+---------------------------------------------------------------+  -
|                                                               |  |
|     &lt;As much of invoking packet as possible without           |  | part of payload
...   the ICMPv6 packet exceeding the minimum IPv6 MTU&gt;       ...  |
|                                                               |  ↓
+---------------------------------------------------------------+  -</code></pre></div><h4 id="rfc-4443-description-2"><a class="doc-anchor" href="#rfc-4443-description-2">§</a>RFC 4443 Description</h4>
<p>If a router receives a packet with a Hop Limit of zero, or if a
router decrements a packet’s Hop Limit to zero, it MUST discard the
packet and originate an ICMPv6 Time Exceeded message with Code 0 to
the source of the packet.  This indicates either a routing loop or
too small an initial Hop Limit value.</p>
<p>An ICMPv6 Time Exceeded message with Code 1 is used to report
fragment reassembly timeout, as specified in [IPv6, Section 4.5].</p>
</div><section id="variant.ParameterProblem" class="variant"><a href="#variant.ParameterProblem" class="anchor">§</a><h3 class="code-header">ParameterProblem(<a class="struct" href="icmpv6/struct.ParameterProblemHeader.html" title="struct etherparse::icmpv6::ParameterProblemHeader">ParameterProblemHeader</a>)</h3></section><div class="docblock"><p>Sent if there is a problem with a parameter in a received packet.</p>
<h4 id="what-is-part-of-the-header-for-icmpv6typeparameterproblem"><a class="doc-anchor" href="#what-is-part-of-the-header-for-icmpv6typeparameterproblem">§</a>What is part of the header for <code>Icmpv6Type::ParameterProblem</code>?</h4>
<p>For the <code>Icmpv6Type::ParameterProblem</code> type the first 8 bytes/octets of the ICMPv6
packet are part of the header. The <code>unused</code> part is not stored and droped.
The offending packet is stored in the payload part of the packet
(<a href="struct.Icmpv6Slice.html#method.payload" title="method etherparse::Icmpv6Slice::payload"><code>Icmpv6Slice::payload</code></a> &amp; <a href="struct.PacketHeaders.html#structfield.payload" title="field etherparse::PacketHeaders::payload"><code>PacketHeaders::payload</code></a>) and is not part of
the <a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a>.</p>
<div class="example-wrap"><pre class="language-text"><code>0               1               2               3               4
+---------------------------------------------------------------+  -
|       4       | [value].code  |  checksum (in Icmpv6Header)   |  |
+---------------------------------------------------------------+  | part of header &amp; type
|                        [value].pointer                        |  ↓
+---------------------------------------------------------------+  -
|                                                               |  |
|     &lt;As much of invoking packet as possible without           |  | part of payload
...   the ICMPv6 packet exceeding the minimum IPv6 MTU&gt;       ...  |
|                                                               |  ↓
+---------------------------------------------------------------+  -</code></pre></div><h4 id="rfc-4443-description-3"><a class="doc-anchor" href="#rfc-4443-description-3">§</a>RFC 4443 Description</h4>
<p>If an IPv6 node processing a packet finds a problem with a field in
the IPv6 header or extension headers such that it cannot complete
processing the packet, it MUST discard the packet and SHOULD
originate an ICMPv6 Parameter Problem message to the packet’s source,
indicating the type and location of the problem.</p>
</div><section id="variant.EchoRequest" class="variant"><a href="#variant.EchoRequest" class="anchor">§</a><h3 class="code-header">EchoRequest(<a class="struct" href="struct.IcmpEchoHeader.html" title="struct etherparse::IcmpEchoHeader">IcmpEchoHeader</a>)</h3></section><div class="docblock"><p>Requesting an <code>EchoReply</code> from the receiver.</p>
<h4 id="what-is-part-of-the-header-for-icmpv6typeechorequest"><a class="doc-anchor" href="#what-is-part-of-the-header-for-icmpv6typeechorequest">§</a>What is part of the header for <code>Icmpv6Type::EchoRequest</code>?</h4>
<p>For the <a href="enum.Icmpv6Type.html#variant.EchoRequest" title="variant etherparse::Icmpv6Type::EchoRequest"><code>Icmpv6Type::EchoRequest</code></a> type the first 8 bytes/octets of the
ICMPv6 packet are part of the header. This includes the <code>id</code> and <code>seq</code>
fields. The data part of the ICMP echo request packet is part of the payload
(<a href="struct.Icmpv6Slice.html#method.payload" title="method etherparse::Icmpv6Slice::payload"><code>Icmpv6Slice::payload</code></a> &amp; <a href="struct.PacketHeaders.html#structfield.payload" title="field etherparse::PacketHeaders::payload"><code>PacketHeaders::payload</code></a>) and not part of the
<a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a>.</p>
<div class="example-wrap"><pre class="language-text"><code>0               1               2               3               4
+---------------------------------------------------------------+  -
|      128      |       0       |  checksum (in Icmpv6Header)   |  |
+---------------------------------------------------------------+  | part of header &amp; type
|          [value].id           |         [value].seq           |  ↓
+---------------------------------------------------------------+  -
|                                                               |  |
...                          &lt;data&gt;                           ...  | part of payload
|                                                               |  ↓
+---------------------------------------------------------------+  -</code></pre></div><h4 id="rfc-4443-description-4"><a class="doc-anchor" href="#rfc-4443-description-4">§</a>RFC 4443 Description</h4>
<p>Every node MUST implement an ICMPv6 Echo responder function that
receives Echo Requests and originates corresponding Echo Replies.  A
node SHOULD also implement an application-layer interface for
originating Echo Requests and receiving Echo Replies, for diagnostic
purposes.</p>
</div><section id="variant.EchoReply" class="variant"><a href="#variant.EchoReply" class="anchor">§</a><h3 class="code-header">EchoReply(<a class="struct" href="struct.IcmpEchoHeader.html" title="struct etherparse::IcmpEchoHeader">IcmpEchoHeader</a>)</h3></section><div class="docblock"><p>Response to an <code>EchoRequest</code> message.</p>
<h4 id="what-is-part-of-the-header-for-icmpv6typeechoreply"><a class="doc-anchor" href="#what-is-part-of-the-header-for-icmpv6typeechoreply">§</a>What is part of the header for <code>Icmpv6Type::EchoReply</code>?</h4>
<p>For the <a href="enum.Icmpv6Type.html#variant.EchoReply" title="variant etherparse::Icmpv6Type::EchoReply"><code>Icmpv6Type::EchoReply</code></a> type the first 8 bytes/octets of the
ICMPv6 packet are part of the header. This includes the <code>id</code> and <code>seq</code>
fields. The data part of the ICMP echo request packet is part of the payload
(<a href="struct.Icmpv6Slice.html#method.payload" title="method etherparse::Icmpv6Slice::payload"><code>Icmpv6Slice::payload</code></a> &amp; <a href="struct.PacketHeaders.html#structfield.payload" title="field etherparse::PacketHeaders::payload"><code>PacketHeaders::payload</code></a>) and not part of the
<a href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header"><code>Icmpv6Header</code></a>.</p>
<div class="example-wrap"><pre class="language-text"><code>0               1               2               3               4
+---------------------------------------------------------------+  -
|      129      |       0       |  checksum (in Icmpv6Header)   |  |
+---------------------------------------------------------------+  | part of header &amp; type
|          [value].id           |         [value].seq           |  ↓
+---------------------------------------------------------------+  -
|                                                               |  |
...                          &lt;data&gt;                           ...  | part of payload
|                                                               |  ↓
+---------------------------------------------------------------+  -</code></pre></div><h4 id="rfc-4443-description-5"><a class="doc-anchor" href="#rfc-4443-description-5">§</a>RFC 4443 Description</h4>
<p>Every node MUST implement an ICMPv6 Echo responder function that
receives Echo Requests and originates corresponding Echo Replies. A
node SHOULD also implement an application-layer interface for
originating Echo Requests and receiving Echo Replies, for diagnostic
purposes.</p>
<p>The source address of an Echo Reply sent in response to a unicast
Echo Request message MUST be the same as the destination address of
that Echo Request message.</p>
<p>An Echo Reply SHOULD be sent in response to an Echo Request message
sent to an IPv6 multicast or anycast address.  In this case, the
source address of the reply MUST be a unicast address belonging to
the interface on which the Echo Request message was received.</p>
<p>The data received in the ICMPv6 Echo Request message MUST be returned
entirely and unmodified in the ICMPv6 Echo Reply message.</p>
</div></div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Icmpv6Type" class="impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#334-501">Source</a><a href="#impl-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_u8" class="method"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#337-352">Source</a><h4 class="code-header">pub fn <a href="#method.type_u8" class="fn">type_u8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Returns the type value (first byte of the ICMPv6 header) of this type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.code_u8" class="method"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#356-371">Source</a><h4 class="code-header">pub fn <a href="#method.code_u8" class="fn">code_u8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Returns the code value (second byte of the ICMPv6 header) of this type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.calc_checksum" class="method"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#384-446">Source</a><h4 class="code-header">pub fn <a href="#method.calc_checksum" class="fn">calc_checksum</a>(
    &amp;self,
    source_ip: [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.array.html">16</a>],
    destination_ip: [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.array.html">16</a>],
    payload: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u16.html">u16</a>, <a class="struct" href="err/struct.ValueTooBigError.html" title="struct etherparse::err::ValueTooBigError">ValueTooBigError</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Calculates the checksum of the ICMPv6 header.</p>
<p style="background:rgba(255,181,77,0.16);padding:0.75em;">
<strong>Warning:</strong> Don't use this method to verfy if a checksum of a
received packet is correct. This method assumes that all unused bytes are
filled with zeros. If this is not the case the computed checksum value will
will be incorrect for a received packet.
<p>If you want to verify that a received packet has a correct checksum use
<a href="struct.Icmpv6Slice.html#method.is_checksum_valid" title="method etherparse::Icmpv6Slice::is_checksum_valid"><code>Icmpv6Slice::is_checksum_valid</code></a> instead.</p>
</p></div></details><details class="toggle method-toggle" open><summary><section id="method.to_header" class="method"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#449-459">Source</a><h4 class="code-header">pub fn <a href="#method.to_header" class="fn">to_header</a>(
    self,
    source_ip: [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.array.html">16</a>],
    destination_ip: [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.array.html">16</a>],
    payload: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Icmpv6Header.html" title="struct etherparse::Icmpv6Header">Icmpv6Header</a>, <a class="struct" href="err/struct.ValueTooBigError.html" title="struct etherparse::err::ValueTooBigError">ValueTooBigError</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Creates a header with the correct checksum.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.header_len" class="method"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#465-480">Source</a><h4 class="code-header">pub fn <a href="#method.header_len" class="fn">header_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Serialized length of the header in bytes/octets.</p>
<p>Note that this size is not the size of the entire
ICMPv6 packet but only the header.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fixed_payload_size" class="method"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#485-500">Source</a><h4 class="code-header">pub fn <a href="#method.fixed_payload_size" class="fn">fixed_payload_size</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>If the ICMP type has a fixed size returns the number of
bytes that should be present after the header of this type.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Icmpv6Type" class="impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#impl-Clone-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Icmpv6Type" class="impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#impl-Debug-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.87.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.87.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Icmpv6Type" class="impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#impl-PartialEq-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.87.0/src/core/cmp.rs.html#262">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Copy-for-Icmpv6Type" class="impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#impl-Copy-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section><section id="impl-Eq-for-Icmpv6Type" class="impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#impl-Eq-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section><section id="impl-StructuralPartialEq-for-Icmpv6Type" class="impl"><a class="src rightside" href="../src/etherparse/transport/icmpv6_type.rs.html#87">Source</a><a href="#impl-StructuralPartialEq-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Icmpv6Type" class="impl"><a href="#impl-Freeze-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section><section id="impl-RefUnwindSafe-for-Icmpv6Type" class="impl"><a href="#impl-RefUnwindSafe-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section><section id="impl-Send-for-Icmpv6Type" class="impl"><a href="#impl-Send-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section><section id="impl-Sync-for-Icmpv6Type" class="impl"><a href="#impl-Sync-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section><section id="impl-Unpin-for-Icmpv6Type" class="impl"><a href="#impl-Unpin-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section><section id="impl-UnwindSafe-for-Icmpv6Type" class="impl"><a href="#impl-UnwindSafe-for-Icmpv6Type" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="enum" href="enum.Icmpv6Type.html" title="enum etherparse::Icmpv6Type">Icmpv6Type</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.87.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#441">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#443">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#806-808">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#810">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#813">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#791-793">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#795">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#798">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>