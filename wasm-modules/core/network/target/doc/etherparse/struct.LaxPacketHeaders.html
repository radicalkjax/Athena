<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Decoded packet headers (data link layer and lower) with lax length checks."><title>LaxPacketHeaders in etherparse - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="etherparse" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../etherparse/index.html">etherparse</a><span class="version">0.14.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">LaxPacket<wbr>Headers</a></h2><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.link" title="link">link</a></li><li><a href="#structfield.net" title="net">net</a></li><li><a href="#structfield.payload" title="payload">payload</a></li><li><a href="#structfield.stop_err" title="stop_err">stop_err</a></li><li><a href="#structfield.transport" title="transport">transport</a></li><li><a href="#structfield.vlan" title="vlan">vlan</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.from_ether_type" title="from_ether_type">from_ether_type</a></li><li><a href="#method.from_ethernet" title="from_ethernet">from_ethernet</a></li><li><a href="#method.from_ip" title="from_ip">from_ip</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-LaxPacketHeaders%3C'a%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-LaxPacketHeaders%3C'a%3E" title="Debug">Debug</a></li><li><a href="#impl-Eq-for-LaxPacketHeaders%3C'a%3E" title="Eq">Eq</a></li><li><a href="#impl-PartialEq-for-LaxPacketHeaders%3C'a%3E" title="PartialEq">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-LaxPacketHeaders%3C'a%3E" title="StructuralPartialEq">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-LaxPacketHeaders%3C'a%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-LaxPacketHeaders%3C'a%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-LaxPacketHeaders%3C'a%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-LaxPacketHeaders%3C'a%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-LaxPacketHeaders%3C'a%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-LaxPacketHeaders%3C'a%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate etherparse</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">etherparse</a></div><h1>Struct <span class="struct">LaxPacketHeaders</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/etherparse/lax_packet_headers.rs.html#17-35">Source</a> </span></div><pre class="rust item-decl"><code>pub struct LaxPacketHeaders&lt;'a&gt; {
    pub link: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Ethernet2Header.html" title="struct etherparse::Ethernet2Header">Ethernet2Header</a>&gt;,
    pub vlan: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.VlanHeader.html" title="enum etherparse::VlanHeader">VlanHeader</a>&gt;,
    pub net: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.NetHeaders.html" title="enum etherparse::NetHeaders">NetHeaders</a>&gt;,
    pub transport: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.TransportHeader.html" title="enum etherparse::TransportHeader">TransportHeader</a>&gt;,
    pub payload: <a class="enum" href="enum.LaxPayloadSlice.html" title="enum etherparse::LaxPayloadSlice">LaxPayloadSlice</a>&lt;'a&gt;,
    pub stop_err: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="enum" href="err/packet/enum.SliceError.html" title="enum etherparse::err::packet::SliceError">SliceError</a>, <a class="enum" href="err/enum.Layer.html" title="enum etherparse::err::Layer">Layer</a>)&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Decoded packet headers (data link layer and lower) with lax length checks.</p>
<p>You can use</p>
<ul>
<li><a href="struct.LaxPacketHeaders.html#method.from_ethernet" title="associated function etherparse::LaxPacketHeaders::from_ethernet"><code>LaxPacketHeaders::from_ethernet</code></a></li>
<li><a href="struct.LaxPacketHeaders.html#method.from_ether_type" title="associated function etherparse::LaxPacketHeaders::from_ether_type"><code>LaxPacketHeaders::from_ether_type</code></a></li>
<li><a href="struct.LaxPacketHeaders.html#method.from_ip" title="associated function etherparse::LaxPacketHeaders::from_ip"><code>LaxPacketHeaders::from_ip</code></a></li>
</ul>
<p>depending on your starting header to parse the headers in a slice and get this
struct as a result.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.link" class="structfield section-header"><a href="#structfield.link" class="anchor field">§</a><code>link: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Ethernet2Header.html" title="struct etherparse::Ethernet2Header">Ethernet2Header</a>&gt;</code></span><div class="docblock"><p>Ethernet II header if present.</p>
</div><span id="structfield.vlan" class="structfield section-header"><a href="#structfield.vlan" class="anchor field">§</a><code>vlan: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.VlanHeader.html" title="enum etherparse::VlanHeader">VlanHeader</a>&gt;</code></span><div class="docblock"><p>Single or double vlan headers if present.</p>
</div><span id="structfield.net" class="structfield section-header"><a href="#structfield.net" class="anchor field">§</a><code>net: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.NetHeaders.html" title="enum etherparse::NetHeaders">NetHeaders</a>&gt;</code></span><div class="docblock"><p>IPv4 or IPv6 header and IP extension headers if present.</p>
</div><span id="structfield.transport" class="structfield section-header"><a href="#structfield.transport" class="anchor field">§</a><code>transport: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.TransportHeader.html" title="enum etherparse::TransportHeader">TransportHeader</a>&gt;</code></span><div class="docblock"><p>TCP or UDP header if present.</p>
</div><span id="structfield.payload" class="structfield section-header"><a href="#structfield.payload" class="anchor field">§</a><code>payload: <a class="enum" href="enum.LaxPayloadSlice.html" title="enum etherparse::LaxPayloadSlice">LaxPayloadSlice</a>&lt;'a&gt;</code></span><div class="docblock"><p>Payload of the last parsed layer.</p>
</div><span id="structfield.stop_err" class="structfield section-header"><a href="#structfield.stop_err" class="anchor field">§</a><code>stop_err: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="enum" href="err/packet/enum.SliceError.html" title="enum etherparse::err::packet::SliceError">SliceError</a>, <a class="enum" href="err/enum.Layer.html" title="enum etherparse::err::Layer">Layer</a>)&gt;</code></span><div class="docblock"><p>Error that stopped the parsing and the layer on which the stop occurred.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-LaxPacketHeaders%3C'a%3E" class="impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#37-567">Source</a><a href="#impl-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_ethernet" class="method"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#127-135">Source</a><h4 class="code-header">pub fn <a href="#method.from_ethernet" class="fn">from_ethernet</a>(slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;, <a class="struct" href="err/struct.LenError.html" title="struct etherparse::err::LenError">LenError</a>&gt;</h4></section></summary><div class="docblock"><p>Separates a network packet into different headers from the ethernet header
downwards with lax length checks and non-terminating errors.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>etherparse::{ether_type, LaxPacketHeaders, LenSource, LaxPayloadSlice};

 <span class="kw">match </span>LaxPacketHeaders::from_ethernet(<span class="kw-2">&amp;</span>packet) {
     <span class="prelude-val">Err</span>(value) =&gt; {
         <span class="comment">// An error is returned in case the ethernet II header could
         // not be parsed (other errors are stored in the "stop_err" field)
         </span><span class="macro">println!</span>(<span class="string">"Err {:?}"</span>, value)
     },
     <span class="prelude-val">Ok</span>(value) =&gt; {
         <span class="kw">if let </span><span class="prelude-val">Some</span>((stop_err, error_layer)) = value.stop_err.as_ref() {
             <span class="comment">// error was encountered after parsing the ethernet 2 header
             </span><span class="macro">println!</span>(<span class="string">"Error on layer {}: {:?}"</span>, error_layer, stop_err);
         }

         <span class="comment">// parts that could be parsed without error
         </span><span class="macro">println!</span>(<span class="string">"link: {:?}"</span>, value.link);
         <span class="macro">println!</span>(<span class="string">"vlan: {:?}"</span>, value.vlan);
         <span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net);
         <span class="macro">println!</span>(<span class="string">"transport: {:?}"</span>, value.transport);

         <span class="comment">// net (ip) &amp; transport (udp or tcp)
         </span><span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net);
         <span class="kw">match </span>value.payload {
             LaxPayloadSlice::Ether(e) =&gt; {
                 <span class="macro">println!</span>(<span class="string">"ether payload (ether type {:?}): {:?}"</span>, e.ether_type, e.payload);
             }
             LaxPayloadSlice::Ip(ip) =&gt; {
                 <span class="macro">println!</span>(<span class="string">"IP payload (IP number {:?}): {:?}"</span>, ip.ip_number, ip.payload);
                 <span class="kw">if </span>ip.incomplete {
                     <span class="macro">println!</span>(<span class="string">"  IP payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
                 <span class="kw">if </span>ip.fragmented {
                     <span class="macro">println!</span>(<span class="string">"  IP payload fragmented"</span>);
                 }
             }
             LaxPayloadSlice::Udp{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"UDP payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  UDP payload incomplete (length in UDP or IP header indicated more data should be present)"</span>);
                 }
             }
             LaxPayloadSlice::Tcp{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"TCP payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  TCP payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
             }
             LaxPayloadSlice::Icmpv4{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"Icmpv4 payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  Icmpv4 payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
             }
             LaxPayloadSlice::Icmpv6{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"Icmpv6 payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  Icmpv6 payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
             }
         }
     }
 }
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_ether_type" class="method"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#235-328">Source</a><h4 class="code-header">pub fn <a href="#method.from_ether_type" class="fn">from_ether_type</a>(
    ether_type: <a class="struct" href="struct.EtherType.html" title="struct etherparse::EtherType">EtherType</a>,
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>],
) -&gt; <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h4></section></summary><div class="docblock"><p>Separates a network packet into different headers using
the given <code>ether_type</code> number to identify the first header with lax length
checks and non-terminating errors.</p>
<p>The result is returned as a <a href="struct.LaxSlicedPacket.html" title="struct etherparse::LaxSlicedPacket"><code>LaxSlicedPacket</code></a> struct. Currently supported
ether type numbers are:</p>
<ul>
<li><code>ether_type::IPV4</code></li>
<li><code>ether_type::IPV6</code></li>
<li><code>ether_type::VLAN_TAGGED_FRAME</code></li>
<li><code>ether_type::PROVIDER_BRIDGING</code></li>
<li><code>ether_type::VLAN_DOUBLE_TAGGED_FRAME</code></li>
</ul>
<p>If an unsupported ether type is given the given slice will be set as payload
and all other fields will be set to <code>None</code>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>etherparse::{ether_type, LaxPacketHeaders, LenSource, LaxPayloadSlice};

 <span class="kw">let </span>value = LaxPacketHeaders::from_ether_type(ether_type::IPV4, <span class="kw-2">&amp;</span>packet);

 <span class="kw">if let </span><span class="prelude-val">Some</span>((stop_err, error_layer)) = value.stop_err.as_ref() {
     <span class="comment">// error was encountered after parsing the ethernet 2 header
     </span><span class="macro">println!</span>(<span class="string">"Error on layer {}: {:?}"</span>, error_layer, stop_err);
 }

 <span class="comment">// link is unfilled
 </span><span class="macro">assert_eq!</span>(value.link, <span class="prelude-val">None</span>);

 <span class="comment">// parts that could be parsed without error
 </span><span class="macro">println!</span>(<span class="string">"vlan: {:?}"</span>, value.vlan);
 <span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net);
 <span class="macro">println!</span>(<span class="string">"transport: {:?}"</span>, value.transport);

 <span class="comment">// net (ip) &amp; transport (udp or tcp)
 </span><span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net);
 <span class="kw">match </span>value.payload {
     LaxPayloadSlice::Ether(e) =&gt; {
         <span class="macro">println!</span>(<span class="string">"ether payload (ether type {:?}): {:?}"</span>, e.ether_type, e.payload);
     }
     LaxPayloadSlice::Ip(ip) =&gt; {
         <span class="macro">println!</span>(<span class="string">"IP payload (IP number {:?}): {:?}"</span>, ip.ip_number, ip.payload);
         <span class="kw">if </span>ip.incomplete {
             <span class="macro">println!</span>(<span class="string">"  IP payload incomplete (length in IP header indicated more data should be present)"</span>);
         }
         <span class="kw">if </span>ip.fragmented {
             <span class="macro">println!</span>(<span class="string">"  IP payload fragmented"</span>);
         }
     }
     LaxPayloadSlice::Udp{ payload, incomplete } =&gt; {
         <span class="macro">println!</span>(<span class="string">"UDP payload: {:?}"</span>, payload);
         <span class="kw">if </span>incomplete {
             <span class="macro">println!</span>(<span class="string">"  UDP payload incomplete (length in UDP or IP header indicated more data should be present)"</span>);
         }
     }
     LaxPayloadSlice::Tcp{ payload, incomplete } =&gt; {
         <span class="macro">println!</span>(<span class="string">"TCP payload: {:?}"</span>, payload);
         <span class="kw">if </span>incomplete {
             <span class="macro">println!</span>(<span class="string">"  TCP payload incomplete (length in IP header indicated more data should be present)"</span>);
         }
     }
     LaxPayloadSlice::Icmpv4{ payload, incomplete } =&gt; {
         <span class="macro">println!</span>(<span class="string">"Icmpv4 payload: {:?}"</span>, payload);
         <span class="kw">if </span>incomplete {
             <span class="macro">println!</span>(<span class="string">"  Icmpv4 payload incomplete (length in IP header indicated more data should be present)"</span>);
         }
     }
     LaxPayloadSlice::Icmpv6{ payload, incomplete } =&gt; {
         <span class="macro">println!</span>(<span class="string">"Icmpv6 payload: {:?}"</span>, payload);
         <span class="kw">if </span>incomplete {
             <span class="macro">println!</span>(<span class="string">"  Icmpv6 payload incomplete (length in IP header indicated more data should be present)"</span>);
         }
     }
 }</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_ip" class="method"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#435-450">Source</a><h4 class="code-header">pub fn <a href="#method.from_ip" class="fn">from_ip</a>(
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'_&gt;, <a class="enum" href="err/ip/enum.LaxHeaderSliceError.html" title="enum etherparse::err::ip::LaxHeaderSliceError">LaxHeaderSliceError</a>&gt;</h4></section></summary><div class="docblock"><p>Separates a network packet slice into different headers from the
ip header downwards with lax length checks and will still return
a result even if an error is encountered in a layer (except IP).</p>
<p>This function has two main differences to <a href="struct.PacketHeaders.html#method.from_ip_slice" title="associated function etherparse::PacketHeaders::from_ip_slice"><code>PacketHeaders::from_ip_slice</code></a>:</p>
<ul>
<li>Errors encountered bellow the IpHeader will only stop the parsing and
return an <code>Ok</code> with the successfully parsed parts and the error as optional.
Only if an unrecoverable error is encountered in the IP header itself an
<code>Err</code> is returned.</li>
<li>Length in the IP header &amp; UDP headers are allowed to be inconsistent with the
given slice length (e.g. data is missing from the slice). In this case it falls
back to the length of slice. See <a href="enum.LaxIpSlice.html#method.from_slice" title="associated function etherparse::LaxIpSlice::from_slice"><code>LaxIpSlice::from_slice</code></a> for a detailed
description of when the slice length is used as a fallback.</li>
</ul>
<p>The result is returned as a <a href="struct.SlicedPacket.html" title="struct etherparse::SlicedPacket"><code>SlicedPacket</code></a> struct. This function
assumes the given data starts with an IPv4 or IPv6 header.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>etherparse::{ether_type, LaxPacketHeaders, LenSource, LaxPayloadSlice};

 <span class="kw">match </span>LaxPacketHeaders::from_ip(<span class="kw-2">&amp;</span>packet) {
     <span class="prelude-val">Err</span>(value) =&gt; {
         <span class="comment">// An error is returned in case the ip header could
         // not be parsed (other errors are stored in the "stop_err" field)
         </span><span class="macro">println!</span>(<span class="string">"Err {:?}"</span>, value)
     },
     <span class="prelude-val">Ok</span>(value) =&gt; {
         <span class="kw">if let </span><span class="prelude-val">Some</span>((stop_err, error_layer)) = value.stop_err.as_ref() {
             <span class="comment">// error was encountered after parsing the ethernet 2 header
             </span><span class="macro">println!</span>(<span class="string">"Error on layer {}: {:?}"</span>, error_layer, stop_err);
         }

         <span class="comment">// link &amp; vlan is unfilled
         </span><span class="macro">assert_eq!</span>(value.link, <span class="prelude-val">None</span>);
         <span class="macro">assert_eq!</span>(value.vlan, <span class="prelude-val">None</span>);

         <span class="comment">// parts that could be parsed without error
         </span><span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net);
         <span class="macro">println!</span>(<span class="string">"transport: {:?}"</span>, value.transport);

         <span class="comment">// net (ip) &amp; transport (udp or tcp)
         </span><span class="macro">println!</span>(<span class="string">"net: {:?}"</span>, value.net);
         <span class="kw">match </span>value.payload {
             <span class="comment">// if you parse from IP down there will be no ether payload
             </span>LaxPayloadSlice::Ether(e) =&gt; <span class="macro">unreachable!</span>(),
             LaxPayloadSlice::Ip(ip) =&gt; {
                 <span class="macro">println!</span>(<span class="string">"IP payload (IP number {:?}): {:?}"</span>, ip.ip_number, ip.payload);
                 <span class="kw">if </span>ip.incomplete {
                     <span class="macro">println!</span>(<span class="string">"  IP payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
                 <span class="kw">if </span>ip.fragmented {
                     <span class="macro">println!</span>(<span class="string">"  IP payload fragmented"</span>);
                 }
             }
             LaxPayloadSlice::Udp{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"UDP payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  UDP payload incomplete (length in UDP or IP header indicated more data should be present)"</span>);
                 }
             }
             LaxPayloadSlice::Tcp{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"TCP payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  TCP payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
             }
             LaxPayloadSlice::Icmpv4{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"Icmpv4 payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  Icmpv4 payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
             }
             LaxPayloadSlice::Icmpv6{ payload, incomplete } =&gt; {
                 <span class="macro">println!</span>(<span class="string">"Icmpv6 payload: {:?}"</span>, payload);
                 <span class="kw">if </span>incomplete {
                     <span class="macro">println!</span>(<span class="string">"  Icmpv6 payload incomplete (length in IP header indicated more data should be present)"</span>);
                 }
             }
         }
     }
 }
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-LaxPacketHeaders%3C'a%3E" class="impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#impl-Clone-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-LaxPacketHeaders%3C'a%3E" class="impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#impl-Debug-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.87.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.87.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-LaxPacketHeaders%3C'a%3E" class="impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#impl-PartialEq-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.87.0/src/core/cmp.rs.html#262">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-LaxPacketHeaders%3C'a%3E" class="impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#impl-Eq-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section><section id="impl-StructuralPartialEq-for-LaxPacketHeaders%3C'a%3E" class="impl"><a class="src rightside" href="../src/etherparse/lax_packet_headers.rs.html#16">Source</a><a href="#impl-StructuralPartialEq-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-LaxPacketHeaders%3C'a%3E" class="impl"><a href="#impl-Freeze-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section><section id="impl-RefUnwindSafe-for-LaxPacketHeaders%3C'a%3E" class="impl"><a href="#impl-RefUnwindSafe-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section><section id="impl-Send-for-LaxPacketHeaders%3C'a%3E" class="impl"><a href="#impl-Send-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section><section id="impl-Sync-for-LaxPacketHeaders%3C'a%3E" class="impl"><a href="#impl-Sync-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section><section id="impl-Unpin-for-LaxPacketHeaders%3C'a%3E" class="impl"><a href="#impl-Unpin-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe-for-LaxPacketHeaders%3C'a%3E" class="impl"><a href="#impl-UnwindSafe-for-LaxPacketHeaders%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.LaxPacketHeaders.html" title="struct etherparse::LaxPacketHeaders">LaxPacketHeaders</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.87.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#441">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#443">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#806-808">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#810">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#813">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#791-793">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#795">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#798">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>