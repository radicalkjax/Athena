// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod athena {
        pub mod crypto {
            /// Hash operations for malware analysis
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod hash {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sha256_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::sha256(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_sha256<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sha256_base64_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::sha256_base64(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_sha256_base64<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sha512_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::sha512(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_sha512<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sha384_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::sha384(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_sha384<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sha1_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::sha1(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_sha1<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_md5_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::md5(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_md5<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                pub trait Guest {
                    /// Compute SHA-256 hash (hex encoded)
                    fn sha256(data: _rt::Vec<u8>) -> _rt::String;
                    /// Compute SHA-256 hash (base64 encoded)
                    fn sha256_base64(data: _rt::Vec<u8>) -> _rt::String;
                    /// Compute SHA-512 hash (hex encoded)
                    fn sha512(data: _rt::Vec<u8>) -> _rt::String;
                    /// Compute SHA-384 hash (hex encoded)
                    fn sha384(data: _rt::Vec<u8>) -> _rt::String;
                    /// Compute SHA-1 hash (hex encoded) - legacy support
                    fn sha1(data: _rt::Vec<u8>) -> _rt::String;
                    /// Compute MD5 hash (hex encoded) - legacy support
                    fn md5(data: _rt::Vec<u8>) -> _rt::String;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_crypto_hash_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:crypto/hash@0.1.0#sha256")] unsafe extern "C" fn
                        export_sha256(arg0 : * mut u8, arg1 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_sha256_cabi::<$ty > (arg0,
                        arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hash@0.1.0#sha256")] unsafe extern "C"
                        fn _post_return_sha256(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_sha256::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "athena:crypto/hash@0.1.0#sha256-base64")] unsafe extern "C" fn
                        export_sha256_base64(arg0 : * mut u8, arg1 : usize,) -> * mut u8
                        { unsafe { $($path_to_types)*:: _export_sha256_base64_cabi::<$ty
                        > (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hash@0.1.0#sha256-base64")] unsafe
                        extern "C" fn _post_return_sha256_base64(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_sha256_base64::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "athena:crypto/hash@0.1.0#sha512")] unsafe extern "C" fn
                        export_sha512(arg0 : * mut u8, arg1 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_sha512_cabi::<$ty > (arg0,
                        arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hash@0.1.0#sha512")] unsafe extern "C"
                        fn _post_return_sha512(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_sha512::<$ty > (arg0) } }
                        #[unsafe (export_name = "athena:crypto/hash@0.1.0#sha384")]
                        unsafe extern "C" fn export_sha384(arg0 : * mut u8, arg1 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_sha384_cabi::<$ty > (arg0, arg1) } } #[unsafe
                        (export_name = "cabi_post_athena:crypto/hash@0.1.0#sha384")]
                        unsafe extern "C" fn _post_return_sha384(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_sha384::<$ty > (arg0)
                        } } #[unsafe (export_name = "athena:crypto/hash@0.1.0#sha1")]
                        unsafe extern "C" fn export_sha1(arg0 : * mut u8, arg1 : usize,)
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_sha1_cabi::<$ty > (arg0, arg1) } } #[unsafe (export_name
                        = "cabi_post_athena:crypto/hash@0.1.0#sha1")] unsafe extern "C"
                        fn _post_return_sha1(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_sha1::<$ty > (arg0) } }
                        #[unsafe (export_name = "athena:crypto/hash@0.1.0#md5")] unsafe
                        extern "C" fn export_md5(arg0 : * mut u8, arg1 : usize,) -> * mut
                        u8 { unsafe { $($path_to_types)*:: _export_md5_cabi::<$ty >
                        (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hash@0.1.0#md5")] unsafe extern "C" fn
                        _post_return_md5(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_md5::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_crypto_hash_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 2 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 2
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// HMAC operations for message authentication
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod hmac {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_hmac_sha256_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::hmac_sha256(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec4 = (result2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr3.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_hmac_sha256<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_hmac_sha256_base64_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::hmac_sha256_base64(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec4 = (result2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr3.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_hmac_sha256_base64<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_hmac_sha512_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::hmac_sha512(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec4 = (result2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr3.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_hmac_sha512<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_hmac_sha384_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::hmac_sha384(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec4 = (result2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr3.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_hmac_sha384<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_verify_hmac_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: *mut u8,
                    arg5: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let len2 = arg5;
                    let bytes2 = _rt::Vec::from_raw_parts(arg4.cast(), len2, len2);
                    let result3 = T::verify_hmac(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                        _rt::string_lift(bytes2),
                    );
                    match result3 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_hmac_key_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::generate_hmac_key(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_hmac_key<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 1, 1);
                }
                pub trait Guest {
                    /// Compute HMAC-SHA256 (hex encoded)
                    fn hmac_sha256(key: _rt::Vec<u8>, data: _rt::Vec<u8>) -> _rt::String;
                    /// Compute HMAC-SHA256 (base64 encoded)
                    fn hmac_sha256_base64(
                        key: _rt::Vec<u8>,
                        data: _rt::Vec<u8>,
                    ) -> _rt::String;
                    /// Compute HMAC-SHA512 (hex encoded)
                    fn hmac_sha512(key: _rt::Vec<u8>, data: _rt::Vec<u8>) -> _rt::String;
                    /// Compute HMAC-SHA384 (hex encoded)
                    fn hmac_sha384(key: _rt::Vec<u8>, data: _rt::Vec<u8>) -> _rt::String;
                    /// Verify HMAC
                    fn verify_hmac(
                        key: _rt::Vec<u8>,
                        data: _rt::Vec<u8>,
                        expected_hmac: _rt::String,
                    ) -> bool;
                    /// Generate random HMAC key
                    fn generate_hmac_key(length: u32) -> _rt::Vec<u8>;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_crypto_hmac_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:crypto/hmac@0.1.0#hmac-sha256")] unsafe extern "C" fn
                        export_hmac_sha256(arg0 : * mut u8, arg1 : usize, arg2 : * mut
                        u8, arg3 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_hmac_sha256_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "cabi_post_athena:crypto/hmac@0.1.0#hmac-sha256")] unsafe extern
                        "C" fn _post_return_hmac_sha256(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_hmac_sha256::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "athena:crypto/hmac@0.1.0#hmac-sha256-base64")] unsafe extern "C"
                        fn export_hmac_sha256_base64(arg0 : * mut u8, arg1 : usize, arg2
                        : * mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_hmac_sha256_base64_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hmac@0.1.0#hmac-sha256-base64")] unsafe
                        extern "C" fn _post_return_hmac_sha256_base64(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_hmac_sha256_base64::<$ty > (arg0) } } #[unsafe
                        (export_name = "athena:crypto/hmac@0.1.0#hmac-sha512")] unsafe
                        extern "C" fn export_hmac_sha512(arg0 : * mut u8, arg1 : usize,
                        arg2 : * mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_hmac_sha512_cabi::<$ty > (arg0,
                        arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hmac@0.1.0#hmac-sha512")] unsafe extern
                        "C" fn _post_return_hmac_sha512(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_hmac_sha512::<$ty > (arg0) } }
                        #[unsafe (export_name = "athena:crypto/hmac@0.1.0#hmac-sha384")]
                        unsafe extern "C" fn export_hmac_sha384(arg0 : * mut u8, arg1 :
                        usize, arg2 : * mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_hmac_sha384_cabi::<$ty > (arg0,
                        arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hmac@0.1.0#hmac-sha384")] unsafe extern
                        "C" fn _post_return_hmac_sha384(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_hmac_sha384::<$ty > (arg0) } }
                        #[unsafe (export_name = "athena:crypto/hmac@0.1.0#verify-hmac")]
                        unsafe extern "C" fn export_verify_hmac(arg0 : * mut u8, arg1 :
                        usize, arg2 : * mut u8, arg3 : usize, arg4 : * mut u8, arg5 :
                        usize,) -> i32 { unsafe { $($path_to_types)*::
                        _export_verify_hmac_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5) } } #[unsafe (export_name =
                        "athena:crypto/hmac@0.1.0#generate-hmac-key")] unsafe extern "C"
                        fn export_generate_hmac_key(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_generate_hmac_key_cabi::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/hmac@0.1.0#generate-hmac-key")] unsafe
                        extern "C" fn _post_return_generate_hmac_key(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_generate_hmac_key::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_crypto_hmac_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 2 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 2
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// AES symmetric encryption
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod aes {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_encrypt_aes128_gcm_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::encrypt_aes128_gcm(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_encrypt_aes128_gcm<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_decrypt_aes128_gcm_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
                    let result2 = T::decrypt_aes128_gcm(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::string_lift(bytes1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec4 = (e).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_decrypt_aes128_gcm<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_encrypt_aes256_gcm_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::encrypt_aes256_gcm(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_encrypt_aes256_gcm<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_decrypt_aes256_gcm_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
                    let result2 = T::decrypt_aes256_gcm(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::string_lift(bytes1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec4 = (e).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_decrypt_aes256_gcm<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_derive_key_from_password_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg3;
                    let result2 = T::derive_key_from_password(
                        _rt::string_lift(bytes0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                        arg4 as u32,
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec4 = (e).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_derive_key_from_password<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_aes_key_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::generate_aes_key(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec2 = (e).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_aes_key<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Encrypt data using AES-128-GCM (returns base64)
                    fn encrypt_aes128_gcm(
                        key: _rt::Vec<u8>,
                        plaintext: _rt::Vec<u8>,
                    ) -> Result<_rt::String, _rt::String>;
                    /// Decrypt data using AES-128-GCM
                    fn decrypt_aes128_gcm(
                        key: _rt::Vec<u8>,
                        ciphertext_base64: _rt::String,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                    /// Encrypt data using AES-256-GCM (returns base64)
                    fn encrypt_aes256_gcm(
                        key: _rt::Vec<u8>,
                        plaintext: _rt::Vec<u8>,
                    ) -> Result<_rt::String, _rt::String>;
                    /// Decrypt data using AES-256-GCM
                    fn decrypt_aes256_gcm(
                        key: _rt::Vec<u8>,
                        ciphertext_base64: _rt::String,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                    /// Derive AES key from password using PBKDF2
                    fn derive_key_from_password(
                        password: _rt::String,
                        salt: _rt::Vec<u8>,
                        key_length: u32,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                    /// Generate random AES key
                    fn generate_aes_key(
                        key_length: u32,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_crypto_aes_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:crypto/aes@0.1.0#encrypt-aes128-gcm")] unsafe extern "C"
                        fn export_encrypt_aes128_gcm(arg0 : * mut u8, arg1 : usize, arg2
                        : * mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_encrypt_aes128_gcm_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/aes@0.1.0#encrypt-aes128-gcm")] unsafe
                        extern "C" fn _post_return_encrypt_aes128_gcm(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_encrypt_aes128_gcm::<$ty > (arg0) } } #[unsafe
                        (export_name = "athena:crypto/aes@0.1.0#decrypt-aes128-gcm")]
                        unsafe extern "C" fn export_decrypt_aes128_gcm(arg0 : * mut u8,
                        arg1 : usize, arg2 : * mut u8, arg3 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_decrypt_aes128_gcm_cabi::<$ty > (arg0, arg1, arg2, arg3)
                        } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/aes@0.1.0#decrypt-aes128-gcm")] unsafe
                        extern "C" fn _post_return_decrypt_aes128_gcm(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_decrypt_aes128_gcm::<$ty > (arg0) } } #[unsafe
                        (export_name = "athena:crypto/aes@0.1.0#encrypt-aes256-gcm")]
                        unsafe extern "C" fn export_encrypt_aes256_gcm(arg0 : * mut u8,
                        arg1 : usize, arg2 : * mut u8, arg3 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_encrypt_aes256_gcm_cabi::<$ty > (arg0, arg1, arg2, arg3)
                        } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/aes@0.1.0#encrypt-aes256-gcm")] unsafe
                        extern "C" fn _post_return_encrypt_aes256_gcm(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_encrypt_aes256_gcm::<$ty > (arg0) } } #[unsafe
                        (export_name = "athena:crypto/aes@0.1.0#decrypt-aes256-gcm")]
                        unsafe extern "C" fn export_decrypt_aes256_gcm(arg0 : * mut u8,
                        arg1 : usize, arg2 : * mut u8, arg3 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_decrypt_aes256_gcm_cabi::<$ty > (arg0, arg1, arg2, arg3)
                        } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/aes@0.1.0#decrypt-aes256-gcm")] unsafe
                        extern "C" fn _post_return_decrypt_aes256_gcm(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_decrypt_aes256_gcm::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "athena:crypto/aes@0.1.0#derive-key-from-password")] unsafe
                        extern "C" fn export_derive_key_from_password(arg0 : * mut u8,
                        arg1 : usize, arg2 : * mut u8, arg3 : usize, arg4 : i32,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_derive_key_from_password_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/aes@0.1.0#derive-key-from-password")]
                        unsafe extern "C" fn _post_return_derive_key_from_password(arg0 :
                        * mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_derive_key_from_password::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "athena:crypto/aes@0.1.0#generate-aes-key")] unsafe extern "C" fn
                        export_generate_aes_key(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_generate_aes_key_cabi::<$ty > (arg0)
                        } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/aes@0.1.0#generate-aes-key")] unsafe
                        extern "C" fn _post_return_generate_aes_key(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_generate_aes_key::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_crypto_aes_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 3 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 3
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// RSA asymmetric encryption
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod rsa {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// RSA key pair representation
                #[derive(Clone)]
                pub struct KeyPair {
                    pub private_key: _rt::Vec<u8>,
                    /// PKCS#8 DER format
                    pub public_key: _rt::Vec<u8>,
                }
                impl ::core::fmt::Debug for KeyPair {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("KeyPair")
                            .field("private-key", &self.private_key)
                            .field("public-key", &self.public_key)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_key_pair_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::generate_key_pair(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let KeyPair {
                                private_key: private_key2,
                                public_key: public_key2,
                            } = e;
                            let vec3 = (private_key2).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                            let vec4 = (public_key2).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr1
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_key_pair<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                            let l4 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base6 = l4;
                            let len6 = l5;
                            _rt::cabi_dealloc(base6, len6 * 1, 1);
                        }
                        _ => {
                            let l7 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sign_sha256_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::sign_sha256(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_sign_sha256<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sign_sha512_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::sign_sha512(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr3
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_sign_sha512<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_verify_sha256_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: *mut u8,
                    arg5: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let len2 = arg5;
                    let bytes2 = _rt::Vec::from_raw_parts(arg4.cast(), len2, len2);
                    let result3 = T::verify_sha256(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                        _rt::string_lift(bytes2),
                    );
                    let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr4
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match e {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr4
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr4
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_verify_sha256<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_verify_sha512_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: *mut u8,
                    arg5: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let len2 = arg5;
                    let bytes2 = _rt::Vec::from_raw_parts(arg4.cast(), len2, len2);
                    let result3 = T::verify_sha512(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                        _rt::string_lift(bytes2),
                    );
                    let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr4
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match e {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr4
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr4
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_verify_sha512<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Generate RSA key pair (2048 or 4096 bits)
                    fn generate_key_pair(key_size: u32) -> Result<KeyPair, _rt::String>;
                    /// Sign data using RSA with SHA-256
                    fn sign_sha256(
                        private_key_der: _rt::Vec<u8>,
                        message: _rt::Vec<u8>,
                    ) -> Result<_rt::String, _rt::String>;
                    /// Sign data using RSA with SHA-512
                    fn sign_sha512(
                        private_key_der: _rt::Vec<u8>,
                        message: _rt::Vec<u8>,
                    ) -> Result<_rt::String, _rt::String>;
                    /// Verify RSA signature with SHA-256
                    fn verify_sha256(
                        public_key_der: _rt::Vec<u8>,
                        message: _rt::Vec<u8>,
                        signature_base64: _rt::String,
                    ) -> Result<bool, _rt::String>;
                    /// Verify RSA signature with SHA-512
                    fn verify_sha512(
                        public_key_der: _rt::Vec<u8>,
                        message: _rt::Vec<u8>,
                        signature_base64: _rt::String,
                    ) -> Result<bool, _rt::String>;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_crypto_rsa_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:crypto/rsa@0.1.0#generate-key-pair")] unsafe extern "C"
                        fn export_generate_key_pair(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_generate_key_pair_cabi::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/rsa@0.1.0#generate-key-pair")] unsafe
                        extern "C" fn _post_return_generate_key_pair(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_generate_key_pair::<$ty > (arg0) } } #[unsafe
                        (export_name = "athena:crypto/rsa@0.1.0#sign-sha256")] unsafe
                        extern "C" fn export_sign_sha256(arg0 : * mut u8, arg1 : usize,
                        arg2 : * mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sign_sha256_cabi::<$ty > (arg0,
                        arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/rsa@0.1.0#sign-sha256")] unsafe extern
                        "C" fn _post_return_sign_sha256(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_sign_sha256::<$ty > (arg0) } }
                        #[unsafe (export_name = "athena:crypto/rsa@0.1.0#sign-sha512")]
                        unsafe extern "C" fn export_sign_sha512(arg0 : * mut u8, arg1 :
                        usize, arg2 : * mut u8, arg3 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sign_sha512_cabi::<$ty > (arg0,
                        arg1, arg2, arg3) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/rsa@0.1.0#sign-sha512")] unsafe extern
                        "C" fn _post_return_sign_sha512(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_sign_sha512::<$ty > (arg0) } }
                        #[unsafe (export_name = "athena:crypto/rsa@0.1.0#verify-sha256")]
                        unsafe extern "C" fn export_verify_sha256(arg0 : * mut u8, arg1 :
                        usize, arg2 : * mut u8, arg3 : usize, arg4 : * mut u8, arg5 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_verify_sha256_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/rsa@0.1.0#verify-sha256")] unsafe extern
                        "C" fn _post_return_verify_sha256(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_verify_sha256::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "athena:crypto/rsa@0.1.0#verify-sha512")] unsafe extern "C" fn
                        export_verify_sha512(arg0 : * mut u8, arg1 : usize, arg2 : * mut
                        u8, arg3 : usize, arg4 : * mut u8, arg5 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_verify_sha512_cabi::<$ty >
                        (arg0, arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/rsa@0.1.0#verify-sha512")] unsafe extern
                        "C" fn _post_return_verify_sha512(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_verify_sha512::<$ty > (arg0) }
                        } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_crypto_rsa_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 5 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 5
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// Cryptographic utilities
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod utils {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_random_bytes_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::generate_random_bytes(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec2 = (e).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_random_bytes<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_random_hex_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::generate_random_hex(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_random_hex<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_random_base64_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::generate_random_base64(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_random_base64<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_constant_time_compare_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let len1 = arg3;
                    let result2 = T::constant_time_compare(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        _rt::Vec::from_raw_parts(arg2.cast(), len1, len1),
                    );
                    match result2 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_hex_to_bytes_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::hex_to_bytes(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_hex_to_bytes<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_bytes_to_hex_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::bytes_to_hex(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_bytes_to_hex<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_base64_encode_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::base64_encode(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = (result1.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_base64_encode<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_base64_decode_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::base64_decode(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_base64_decode<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Generate cryptographically secure random bytes
                    fn generate_random_bytes(
                        length: u32,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                    /// Generate random hex string
                    fn generate_random_hex(
                        length: u32,
                    ) -> Result<_rt::String, _rt::String>;
                    /// Generate random base64 string
                    fn generate_random_base64(
                        length: u32,
                    ) -> Result<_rt::String, _rt::String>;
                    /// Constant-time comparison (timing attack resistant)
                    fn constant_time_compare(a: _rt::Vec<u8>, b: _rt::Vec<u8>) -> bool;
                    /// Convert hex string to bytes
                    fn hex_to_bytes(
                        hex: _rt::String,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                    /// Convert bytes to hex string
                    fn bytes_to_hex(bytes: _rt::Vec<u8>) -> _rt::String;
                    /// Base64 encode
                    fn base64_encode(data: _rt::Vec<u8>) -> _rt::String;
                    /// Base64 decode
                    fn base64_decode(
                        encoded: _rt::String,
                    ) -> Result<_rt::Vec<u8>, _rt::String>;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_crypto_utils_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:crypto/utils@0.1.0#generate-random-bytes")] unsafe extern
                        "C" fn export_generate_random_bytes(arg0 : i32,) -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_generate_random_bytes_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_athena:crypto/utils@0.1.0#generate-random-bytes")]
                        unsafe extern "C" fn _post_return_generate_random_bytes(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_generate_random_bytes::<$ty > (arg0) } } #[unsafe
                        (export_name = "athena:crypto/utils@0.1.0#generate-random-hex")]
                        unsafe extern "C" fn export_generate_random_hex(arg0 : i32,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_generate_random_hex_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_athena:crypto/utils@0.1.0#generate-random-hex")]
                        unsafe extern "C" fn _post_return_generate_random_hex(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_generate_random_hex::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "athena:crypto/utils@0.1.0#generate-random-base64")] unsafe
                        extern "C" fn export_generate_random_base64(arg0 : i32,) -> * mut
                        u8 { unsafe { $($path_to_types)*::
                        _export_generate_random_base64_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_athena:crypto/utils@0.1.0#generate-random-base64")]
                        unsafe extern "C" fn _post_return_generate_random_base64(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_generate_random_base64::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "athena:crypto/utils@0.1.0#constant-time-compare")] unsafe extern
                        "C" fn export_constant_time_compare(arg0 : * mut u8, arg1 :
                        usize, arg2 : * mut u8, arg3 : usize,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_constant_time_compare_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "athena:crypto/utils@0.1.0#hex-to-bytes")] unsafe extern "C" fn
                        export_hex_to_bytes(arg0 : * mut u8, arg1 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_hex_to_bytes_cabi::<$ty >
                        (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/utils@0.1.0#hex-to-bytes")] unsafe
                        extern "C" fn _post_return_hex_to_bytes(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_hex_to_bytes::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "athena:crypto/utils@0.1.0#bytes-to-hex")] unsafe extern "C" fn
                        export_bytes_to_hex(arg0 : * mut u8, arg1 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_bytes_to_hex_cabi::<$ty >
                        (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/utils@0.1.0#bytes-to-hex")] unsafe
                        extern "C" fn _post_return_bytes_to_hex(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_bytes_to_hex::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "athena:crypto/utils@0.1.0#base64-encode")] unsafe extern "C" fn
                        export_base64_encode(arg0 : * mut u8, arg1 : usize,) -> * mut u8
                        { unsafe { $($path_to_types)*:: _export_base64_encode_cabi::<$ty
                        > (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/utils@0.1.0#base64-encode")] unsafe
                        extern "C" fn _post_return_base64_encode(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_base64_encode::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "athena:crypto/utils@0.1.0#base64-decode")] unsafe extern "C" fn
                        export_base64_decode(arg0 : * mut u8, arg1 : usize,) -> * mut u8
                        { unsafe { $($path_to_types)*:: _export_base64_decode_cabi::<$ty
                        > (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_athena:crypto/utils@0.1.0#base64-decode")] unsafe
                        extern "C" fn _post_return_base64_decode(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_base64_decode::<$ty >
                        (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_crypto_utils_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 3 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 3
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub use alloc_crate::vec::Vec;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::string::String;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_crypto_component_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::athena::crypto::hash::__export_athena_crypto_hash_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::athena::crypto::hash);
        $($path_to_types_root)*::
        exports::athena::crypto::hmac::__export_athena_crypto_hmac_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::athena::crypto::hmac);
        $($path_to_types_root)*::
        exports::athena::crypto::aes::__export_athena_crypto_aes_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::athena::crypto::aes);
        $($path_to_types_root)*::
        exports::athena::crypto::rsa::__export_athena_crypto_rsa_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::athena::crypto::rsa);
        $($path_to_types_root)*::
        exports::athena::crypto::utils::__export_athena_crypto_utils_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::athena::crypto::utils);
    };
}
#[doc(inline)]
pub(crate) use __export_crypto_component_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:athena:crypto@0.1.0:crypto-component:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1371] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd4\x09\x01A\x02\x01\
A\x0a\x01B\x08\x01p}\x01@\x01\x04data\0\0s\x04\0\x06sha256\x01\x01\x04\0\x0dsha2\
56-base64\x01\x01\x04\0\x06sha512\x01\x01\x04\0\x06sha384\x01\x01\x04\0\x04sha1\x01\
\x01\x04\0\x03md5\x01\x01\x04\0\x18athena:crypto/hash@0.1.0\x05\0\x01B\x0a\x01p}\
\x01@\x02\x03key\0\x04data\0\0s\x04\0\x0bhmac-sha256\x01\x01\x04\0\x12hmac-sha25\
6-base64\x01\x01\x04\0\x0bhmac-sha512\x01\x01\x04\0\x0bhmac-sha384\x01\x01\x01@\x03\
\x03key\0\x04data\0\x0dexpected-hmacs\0\x7f\x04\0\x0bverify-hmac\x01\x02\x01@\x01\
\x06lengthy\0\0\x04\0\x11generate-hmac-key\x01\x03\x04\0\x18athena:crypto/hmac@0\
.1.0\x05\x01\x01B\x0d\x01p}\x01j\x01s\x01s\x01@\x02\x03key\0\x09plaintext\0\0\x01\
\x04\0\x12encrypt-aes128-gcm\x01\x02\x01j\x01\0\x01s\x01@\x02\x03key\0\x11cipher\
text-base64s\0\x03\x04\0\x12decrypt-aes128-gcm\x01\x04\x04\0\x12encrypt-aes256-g\
cm\x01\x02\x04\0\x12decrypt-aes256-gcm\x01\x04\x01@\x03\x08passwords\x04salt\0\x0a\
key-lengthy\0\x03\x04\0\x18derive-key-from-password\x01\x05\x01@\x01\x0akey-leng\
thy\0\x03\x04\0\x10generate-aes-key\x01\x06\x04\0\x17athena:crypto/aes@0.1.0\x05\
\x02\x01B\x0e\x01p}\x01r\x02\x0bprivate-key\0\x0apublic-key\0\x04\0\x08key-pair\x03\
\0\x01\x01j\x01\x02\x01s\x01@\x01\x08key-sizey\0\x03\x04\0\x11generate-key-pair\x01\
\x04\x01j\x01s\x01s\x01@\x02\x0fprivate-key-der\0\x07message\0\0\x05\x04\0\x0bsi\
gn-sha256\x01\x06\x04\0\x0bsign-sha512\x01\x06\x01j\x01\x7f\x01s\x01@\x03\x0epub\
lic-key-der\0\x07message\0\x10signature-base64s\0\x07\x04\0\x0dverify-sha256\x01\
\x08\x04\0\x0dverify-sha512\x01\x08\x04\0\x17athena:crypto/rsa@0.1.0\x05\x03\x01\
B\x12\x01p}\x01j\x01\0\x01s\x01@\x01\x06lengthy\0\x01\x04\0\x15generate-random-b\
ytes\x01\x02\x01j\x01s\x01s\x01@\x01\x06lengthy\0\x03\x04\0\x13generate-random-h\
ex\x01\x04\x04\0\x16generate-random-base64\x01\x04\x01@\x02\x01a\0\x01b\0\0\x7f\x04\
\0\x15constant-time-compare\x01\x05\x01@\x01\x03hexs\0\x01\x04\0\x0chex-to-bytes\
\x01\x06\x01@\x01\x05bytes\0\0s\x04\0\x0cbytes-to-hex\x01\x07\x01@\x01\x04data\0\
\0s\x04\0\x0dbase64-encode\x01\x08\x01@\x01\x07encodeds\0\x01\x04\0\x0dbase64-de\
code\x01\x09\x04\0\x19athena:crypto/utils@0.1.0\x05\x04\x04\0$athena:crypto/cryp\
to-component@0.1.0\x04\0\x0b\x16\x01\0\x10crypto-component\x03\0\0\0G\x09produce\
rs\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.\
41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
