// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod athena {
        pub mod file_processor {
            /// File format detection and identification
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod detector {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// File format enumeration
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum FileFormat {
                    /// Executables
                    Pe32,
                    Pe64,
                    Elf32,
                    Elf64,
                    Macho,
                    /// Documents
                    Pdf,
                    Docx,
                    Xlsx,
                    Pptx,
                    Odt,
                    /// Archives
                    Zip,
                    Rar,
                    Sevenz,
                    Tar,
                    Gzip,
                    /// Scripts
                    Javascript,
                    Typescript,
                    Python,
                    Powershell,
                    Batch,
                    Shell,
                    Php,
                    Ruby,
                    /// Web
                    Html,
                    Xml,
                    Json,
                    Css,
                    /// Other
                    PlainText,
                    Binary,
                    Unknown,
                }
                impl ::core::fmt::Debug for FileFormat {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            FileFormat::Pe32 => {
                                f.debug_tuple("FileFormat::Pe32").finish()
                            }
                            FileFormat::Pe64 => {
                                f.debug_tuple("FileFormat::Pe64").finish()
                            }
                            FileFormat::Elf32 => {
                                f.debug_tuple("FileFormat::Elf32").finish()
                            }
                            FileFormat::Elf64 => {
                                f.debug_tuple("FileFormat::Elf64").finish()
                            }
                            FileFormat::Macho => {
                                f.debug_tuple("FileFormat::Macho").finish()
                            }
                            FileFormat::Pdf => f.debug_tuple("FileFormat::Pdf").finish(),
                            FileFormat::Docx => {
                                f.debug_tuple("FileFormat::Docx").finish()
                            }
                            FileFormat::Xlsx => {
                                f.debug_tuple("FileFormat::Xlsx").finish()
                            }
                            FileFormat::Pptx => {
                                f.debug_tuple("FileFormat::Pptx").finish()
                            }
                            FileFormat::Odt => f.debug_tuple("FileFormat::Odt").finish(),
                            FileFormat::Zip => f.debug_tuple("FileFormat::Zip").finish(),
                            FileFormat::Rar => f.debug_tuple("FileFormat::Rar").finish(),
                            FileFormat::Sevenz => {
                                f.debug_tuple("FileFormat::Sevenz").finish()
                            }
                            FileFormat::Tar => f.debug_tuple("FileFormat::Tar").finish(),
                            FileFormat::Gzip => {
                                f.debug_tuple("FileFormat::Gzip").finish()
                            }
                            FileFormat::Javascript => {
                                f.debug_tuple("FileFormat::Javascript").finish()
                            }
                            FileFormat::Typescript => {
                                f.debug_tuple("FileFormat::Typescript").finish()
                            }
                            FileFormat::Python => {
                                f.debug_tuple("FileFormat::Python").finish()
                            }
                            FileFormat::Powershell => {
                                f.debug_tuple("FileFormat::Powershell").finish()
                            }
                            FileFormat::Batch => {
                                f.debug_tuple("FileFormat::Batch").finish()
                            }
                            FileFormat::Shell => {
                                f.debug_tuple("FileFormat::Shell").finish()
                            }
                            FileFormat::Php => f.debug_tuple("FileFormat::Php").finish(),
                            FileFormat::Ruby => {
                                f.debug_tuple("FileFormat::Ruby").finish()
                            }
                            FileFormat::Html => {
                                f.debug_tuple("FileFormat::Html").finish()
                            }
                            FileFormat::Xml => f.debug_tuple("FileFormat::Xml").finish(),
                            FileFormat::Json => {
                                f.debug_tuple("FileFormat::Json").finish()
                            }
                            FileFormat::Css => f.debug_tuple("FileFormat::Css").finish(),
                            FileFormat::PlainText => {
                                f.debug_tuple("FileFormat::PlainText").finish()
                            }
                            FileFormat::Binary => {
                                f.debug_tuple("FileFormat::Binary").finish()
                            }
                            FileFormat::Unknown => {
                                f.debug_tuple("FileFormat::Unknown").finish()
                            }
                        }
                    }
                }
                impl FileFormat {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> FileFormat {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => FileFormat::Pe32,
                            1 => FileFormat::Pe64,
                            2 => FileFormat::Elf32,
                            3 => FileFormat::Elf64,
                            4 => FileFormat::Macho,
                            5 => FileFormat::Pdf,
                            6 => FileFormat::Docx,
                            7 => FileFormat::Xlsx,
                            8 => FileFormat::Pptx,
                            9 => FileFormat::Odt,
                            10 => FileFormat::Zip,
                            11 => FileFormat::Rar,
                            12 => FileFormat::Sevenz,
                            13 => FileFormat::Tar,
                            14 => FileFormat::Gzip,
                            15 => FileFormat::Javascript,
                            16 => FileFormat::Typescript,
                            17 => FileFormat::Python,
                            18 => FileFormat::Powershell,
                            19 => FileFormat::Batch,
                            20 => FileFormat::Shell,
                            21 => FileFormat::Php,
                            22 => FileFormat::Ruby,
                            23 => FileFormat::Html,
                            24 => FileFormat::Xml,
                            25 => FileFormat::Json,
                            26 => FileFormat::Css,
                            27 => FileFormat::PlainText,
                            28 => FileFormat::Binary,
                            29 => FileFormat::Unknown,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_detect_format_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: *mut u8,
                    arg4: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result2 = T::detect_format(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        match arg2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len1 = arg4;
                                    let bytes1 = _rt::Vec::from_raw_parts(
                                        arg3.cast(),
                                        len1,
                                        len1,
                                    );
                                    _rt::string_lift(bytes1)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    result2.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_is_text_file_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::is_text_file(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                    );
                    match result1 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_mime_type_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_mime_type(FileFormat::_lift(arg0 as u8));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_mime_type<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                pub trait Guest {
                    /// Detect file format from buffer and optional filename
                    fn detect_format(
                        buffer: _rt::Vec<u8>,
                        filename: Option<_rt::String>,
                    ) -> FileFormat;
                    /// Check if file appears to be text
                    fn is_text_file(buffer: _rt::Vec<u8>) -> bool;
                    /// Get MIME type for a file format
                    fn get_mime_type(format: FileFormat) -> _rt::String;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_file_processor_detector_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:file-processor/detector@0.1.0#detect-format")] unsafe
                        extern "C" fn export_detect_format(arg0 : * mut u8, arg1 : usize,
                        arg2 : i32, arg3 : * mut u8, arg4 : usize,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_detect_format_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4) } } #[unsafe (export_name =
                        "athena:file-processor/detector@0.1.0#is-text-file")] unsafe
                        extern "C" fn export_is_text_file(arg0 : * mut u8, arg1 : usize,)
                        -> i32 { unsafe { $($path_to_types)*::
                        _export_is_text_file_cabi::<$ty > (arg0, arg1) } } #[unsafe
                        (export_name =
                        "athena:file-processor/detector@0.1.0#get-mime-type")] unsafe
                        extern "C" fn export_get_mime_type(arg0 : i32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_get_mime_type_cabi::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "cabi_post_athena:file-processor/detector@0.1.0#get-mime-type")]
                        unsafe extern "C" fn _post_return_get_mime_type(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_get_mime_type::<$ty
                        > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_file_processor_detector_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 2 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 2
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// File validation for security and integrity
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod validator {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type FileFormat = super::super::super::super::exports::athena::file_processor::detector::FileFormat;
                /// Validation result
                #[derive(Clone)]
                pub struct ValidationResult {
                    pub is_valid: bool,
                    pub format_valid: bool,
                    pub size_valid: bool,
                    pub content_safe: bool,
                    pub errors: _rt::Vec<_rt::String>,
                    pub warnings: _rt::Vec<_rt::String>,
                }
                impl ::core::fmt::Debug for ValidationResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ValidationResult")
                            .field("is-valid", &self.is_valid)
                            .field("format-valid", &self.format_valid)
                            .field("size-valid", &self.size_valid)
                            .field("content-safe", &self.content_safe)
                            .field("errors", &self.errors)
                            .field("warnings", &self.warnings)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_validate_file_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::validate_file(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        super::super::super::super::exports::athena::file_processor::detector::FileFormat::_lift(
                            arg2 as u8,
                        ),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let ValidationResult {
                        is_valid: is_valid3,
                        format_valid: format_valid3,
                        size_valid: size_valid3,
                        content_safe: content_safe3,
                        errors: errors3,
                        warnings: warnings3,
                    } = result1;
                    *ptr2.add(0).cast::<u8>() = (match is_valid3 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr2.add(1).cast::<u8>() = (match format_valid3 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr2.add(2).cast::<u8>() = (match size_valid3 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr2.add(3).cast::<u8>() = (match content_safe3 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    let vec5 = errors3;
                    let len5 = vec5.len();
                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec5.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result5 = if layout5.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout5);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    }
                    *ptr2.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result5;
                    let vec7 = warnings3;
                    let len7 = vec7.len();
                    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec7.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result7 = if layout7.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout7);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec7.into_iter().enumerate() {
                        let base = result7
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec6 = (e.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                        }
                    }
                    *ptr2.add(4 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr2
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result7;
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_validate_file<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l1 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base4 = l0;
                    let len4 = l1;
                    for i in 0..len4 {
                        let base = base4
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base4,
                        len4 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l5 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l6 = *arg0
                        .add(4 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base9 = l5;
                    let len9 = l6;
                    for i in 0..len9 {
                        let base = base9
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l7 = *base.add(0).cast::<*mut u8>();
                            let l8 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base9,
                        len9 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                pub trait Guest {
                    /// Validate file for security and integrity
                    fn validate_file(
                        buffer: _rt::Vec<u8>,
                        format: FileFormat,
                    ) -> ValidationResult;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_file_processor_validator_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:file-processor/validator@0.1.0#validate-file")] unsafe
                        extern "C" fn export_validate_file(arg0 : * mut u8, arg1 : usize,
                        arg2 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_validate_file_cabi::<$ty > (arg0, arg1, arg2) } }
                        #[unsafe (export_name =
                        "cabi_post_athena:file-processor/validator@0.1.0#validate-file")]
                        unsafe extern "C" fn _post_return_validate_file(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_validate_file::<$ty
                        > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_file_processor_validator_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 5 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 5
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// File parsing and analysis
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod parser {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type FileFormat = super::super::super::super::exports::athena::file_processor::detector::FileFormat;
                /// File section information
                #[derive(Clone)]
                pub struct FileSection {
                    pub name: _rt::String,
                    pub offset: u64,
                    pub size: u64,
                    pub entropy: f64,
                    pub section_flags: _rt::Vec<_rt::String>,
                }
                impl ::core::fmt::Debug for FileSection {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("FileSection")
                            .field("name", &self.name)
                            .field("offset", &self.offset)
                            .field("size", &self.size)
                            .field("entropy", &self.entropy)
                            .field("section-flags", &self.section_flags)
                            .finish()
                    }
                }
                /// Embedded file information
                #[derive(Clone)]
                pub struct EmbeddedFile {
                    pub name: Option<_rt::String>,
                    pub format: FileFormat,
                    pub offset: u64,
                    pub size: u64,
                    pub hash: _rt::String,
                }
                impl ::core::fmt::Debug for EmbeddedFile {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("EmbeddedFile")
                            .field("name", &self.name)
                            .field("format", &self.format)
                            .field("offset", &self.offset)
                            .field("size", &self.size)
                            .field("hash", &self.hash)
                            .finish()
                    }
                }
                /// Suspicious severity levels
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum SuspiciousSeverity {
                    Low,
                    Medium,
                    High,
                    Critical,
                }
                impl ::core::fmt::Debug for SuspiciousSeverity {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            SuspiciousSeverity::Low => {
                                f.debug_tuple("SuspiciousSeverity::Low").finish()
                            }
                            SuspiciousSeverity::Medium => {
                                f.debug_tuple("SuspiciousSeverity::Medium").finish()
                            }
                            SuspiciousSeverity::High => {
                                f.debug_tuple("SuspiciousSeverity::High").finish()
                            }
                            SuspiciousSeverity::Critical => {
                                f.debug_tuple("SuspiciousSeverity::Critical").finish()
                            }
                        }
                    }
                }
                impl SuspiciousSeverity {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> SuspiciousSeverity {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => SuspiciousSeverity::Low,
                            1 => SuspiciousSeverity::Medium,
                            2 => SuspiciousSeverity::High,
                            3 => SuspiciousSeverity::Critical,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Suspicious indicator
                #[derive(Clone)]
                pub struct SuspiciousIndicator {
                    pub indicator_type: _rt::String,
                    pub description: _rt::String,
                    pub severity: SuspiciousSeverity,
                    pub location: Option<_rt::String>,
                    pub evidence: _rt::String,
                }
                impl ::core::fmt::Debug for SuspiciousIndicator {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SuspiciousIndicator")
                            .field("indicator-type", &self.indicator_type)
                            .field("description", &self.description)
                            .field("severity", &self.severity)
                            .field("location", &self.location)
                            .field("evidence", &self.evidence)
                            .finish()
                    }
                }
                /// File integrity information
                #[derive(Clone)]
                pub struct FileIntegrity {
                    pub valid_structure: bool,
                    pub checksum_valid: Option<bool>,
                    pub signature_valid: Option<bool>,
                    pub issues: _rt::Vec<_rt::String>,
                }
                impl ::core::fmt::Debug for FileIntegrity {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("FileIntegrity")
                            .field("valid-structure", &self.valid_structure)
                            .field("checksum-valid", &self.checksum_valid)
                            .field("signature-valid", &self.signature_valid)
                            .field("issues", &self.issues)
                            .finish()
                    }
                }
                /// File metadata
                #[derive(Clone)]
                pub struct FileMetadata {
                    pub size: u64,
                    pub hash: _rt::String,
                    pub mime_type: _rt::String,
                    pub created_at: Option<_rt::String>,
                    pub modified_at: Option<_rt::String>,
                    /// Note: WIT doesn't support HashMap directly, using list of key-value pairs
                    pub attributes: _rt::Vec<(_rt::String, _rt::String)>,
                }
                impl ::core::fmt::Debug for FileMetadata {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("FileMetadata")
                            .field("size", &self.size)
                            .field("hash", &self.hash)
                            .field("mime-type", &self.mime_type)
                            .field("created-at", &self.created_at)
                            .field("modified-at", &self.modified_at)
                            .field("attributes", &self.attributes)
                            .finish()
                    }
                }
                /// Parsed file structure
                #[derive(Clone)]
                pub struct ParsedFile {
                    pub format: FileFormat,
                    pub metadata: FileMetadata,
                    pub sections: _rt::Vec<FileSection>,
                    pub embedded_files: _rt::Vec<EmbeddedFile>,
                    pub strings: _rt::Vec<_rt::String>,
                    /// Simplified for WIT
                    pub suspicious_indicators: _rt::Vec<SuspiciousIndicator>,
                    pub integrity: FileIntegrity,
                }
                impl ::core::fmt::Debug for ParsedFile {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ParsedFile")
                            .field("format", &self.format)
                            .field("metadata", &self.metadata)
                            .field("sections", &self.sections)
                            .field("embedded-files", &self.embedded_files)
                            .field("strings", &self.strings)
                            .field("suspicious-indicators", &self.suspicious_indicators)
                            .field("integrity", &self.integrity)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_parse_file_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::parse_file(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        match arg2 {
                            0 => None,
                            1 => {
                                let e = super::super::super::super::exports::athena::file_processor::detector::FileFormat::_lift(
                                    arg3 as u8,
                                );
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let ParsedFile {
                                format: format3,
                                metadata: metadata3,
                                sections: sections3,
                                embedded_files: embedded_files3,
                                strings: strings3,
                                suspicious_indicators: suspicious_indicators3,
                                integrity: integrity3,
                            } = e;
                            *ptr2.add(8).cast::<u8>() = (format3.clone() as i32) as u8;
                            let FileMetadata {
                                size: size4,
                                hash: hash4,
                                mime_type: mime_type4,
                                created_at: created_at4,
                                modified_at: modified_at4,
                                attributes: attributes4,
                            } = metadata3;
                            *ptr2.add(16).cast::<i64>() = _rt::as_i64(size4);
                            let vec5 = (hash4.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr2
                                .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr2.add(24).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = (mime_type4.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr2
                                .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *ptr2
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr6.cast_mut();
                            match created_at4 {
                                Some(e) => {
                                    *ptr2
                                        .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2
                                        .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                None => {
                                    *ptr2
                                        .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match modified_at4 {
                                Some(e) => {
                                    *ptr2
                                        .add(24 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(24 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2
                                        .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                None => {
                                    *ptr2
                                        .add(24 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec12 = attributes4;
                            let len12 = vec12.len();
                            let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec12.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result12 = if layout12.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout12);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec12.into_iter().enumerate() {
                                let base = result12
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t9_0, t9_1) = e;
                                    let vec10 = (t9_0.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *base.add(0).cast::<*mut u8>() = ptr10.cast_mut();
                                    let vec11 = (t9_1.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr11.cast_mut();
                                }
                            }
                            *ptr2
                                .add(24 + 11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len12;
                            *ptr2
                                .add(24 + 10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result12;
                            let vec17 = sections3;
                            let len17 = vec17.len();
                            let layout17 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec17.len()
                                    * (24 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result17 = if layout17.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout17).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout17);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec17.into_iter().enumerate() {
                                let base = result17
                                    .add(i * (24 + 4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let FileSection {
                                        name: name13,
                                        offset: offset13,
                                        size: size13,
                                        entropy: entropy13,
                                        section_flags: section_flags13,
                                    } = e;
                                    let vec14 = (name13.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *base.add(0).cast::<*mut u8>() = ptr14.cast_mut();
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(offset13);
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(size13);
                                    *base
                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f64>() = _rt::as_f64(entropy13);
                                    let vec16 = section_flags13;
                                    let len16 = vec16.len();
                                    let layout16 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec16.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result16 = if layout16.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout16).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout16);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec16.into_iter().enumerate() {
                                        let base = result16
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec15 = (e.into_bytes()).into_boxed_slice();
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            ::core::mem::forget(vec15);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len15;
                                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *base
                                        .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result16;
                                }
                            }
                            *ptr2
                                .add(24 + 13 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len17;
                            *ptr2
                                .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result17;
                            let vec21 = embedded_files3;
                            let len21 = vec21.len();
                            let layout21 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec21.len()
                                    * (16 + 6 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let result21 = if layout21.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout21).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout21);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec21.into_iter().enumerate() {
                                let base = result21
                                    .add(i * (16 + 6 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let EmbeddedFile {
                                        name: name18,
                                        format: format18,
                                        offset: offset18,
                                        size: size18,
                                        hash: hash18,
                                    } = e;
                                    match name18 {
                                        Some(e) => {
                                            *base.add(0).cast::<u8>() = (1i32) as u8;
                                            let vec19 = (e.into_bytes()).into_boxed_slice();
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            ::core::mem::forget(vec19);
                                            *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len19;
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr19.cast_mut();
                                        }
                                        None => {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (format18.clone() as i32) as u8;
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(offset18);
                                    *base
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(size18);
                                    let vec20 = (hash18.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *base
                                        .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *base
                                        .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                            *ptr2
                                .add(24 + 15 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len21;
                            *ptr2
                                .add(24 + 14 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result21;
                            let vec23 = strings3;
                            let len23 = vec23.len();
                            let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec23.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result23 = if layout23.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout23);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec23.into_iter().enumerate() {
                                let base = result23
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *base.add(0).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                            }
                            *ptr2
                                .add(24 + 17 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len23;
                            *ptr2
                                .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result23;
                            let vec29 = suspicious_indicators3;
                            let len29 = vec29.len();
                            let layout29 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec29.len() * (10 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result29 = if layout29.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout29).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout29);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec29.into_iter().enumerate() {
                                let base = result29
                                    .add(i * (10 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let SuspiciousIndicator {
                                        indicator_type: indicator_type24,
                                        description: description24,
                                        severity: severity24,
                                        location: location24,
                                        evidence: evidence24,
                                    } = e;
                                    let vec25 = (indicator_type24.into_bytes())
                                        .into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len25;
                                    *base.add(0).cast::<*mut u8>() = ptr25.cast_mut();
                                    let vec26 = (description24.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len26;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr26.cast_mut();
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (severity24.clone() as i32) as u8;
                                    match location24 {
                                        Some(e) => {
                                            *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec27 = (e.into_bytes()).into_boxed_slice();
                                            let ptr27 = vec27.as_ptr().cast::<u8>();
                                            let len27 = vec27.len();
                                            ::core::mem::forget(vec27);
                                            *base
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len27;
                                            *base
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr27.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec28 = (evidence24.into_bytes()).into_boxed_slice();
                                    let ptr28 = vec28.as_ptr().cast::<u8>();
                                    let len28 = vec28.len();
                                    ::core::mem::forget(vec28);
                                    *base
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len28;
                                    *base
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr28.cast_mut();
                                }
                            }
                            *ptr2
                                .add(24 + 19 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len29;
                            *ptr2
                                .add(24 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result29;
                            let FileIntegrity {
                                valid_structure: valid_structure30,
                                checksum_valid: checksum_valid30,
                                signature_valid: signature_valid30,
                                issues: issues30,
                            } = integrity3;
                            *ptr2
                                .add(24 + 20 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match valid_structure30 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            match checksum_valid30 {
                                Some(e) => {
                                    *ptr2
                                        .add(25 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr2
                                        .add(26 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                None => {
                                    *ptr2
                                        .add(25 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match signature_valid30 {
                                Some(e) => {
                                    *ptr2
                                        .add(27 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr2
                                        .add(28 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match e {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                }
                                None => {
                                    *ptr2
                                        .add(27 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec32 = issues30;
                            let len32 = vec32.len();
                            let layout32 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec32.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result32 = if layout32.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout32).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout32);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec32.into_iter().enumerate() {
                                let base = result32
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec31 = (e.into_bytes()).into_boxed_slice();
                                    let ptr31 = vec31.as_ptr().cast::<u8>();
                                    let len31 = vec31.len();
                                    ::core::mem::forget(vec31);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len31;
                                    *base.add(0).cast::<*mut u8>() = ptr31.cast_mut();
                                }
                            }
                            *ptr2
                                .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len32;
                            *ptr2
                                .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result32;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec33 = (e.into_bytes()).into_boxed_slice();
                            let ptr33 = vec33.as_ptr().cast::<u8>();
                            let len33 = vec33.len();
                            ::core::mem::forget(vec33);
                            *ptr2
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len33;
                            *ptr2.add(8).cast::<*mut u8>() = ptr33.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_parse_file<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(24).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                            let l5 = i32::from(
                                *arg0
                                    .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l5 {
                                0 => {}
                                _ => {
                                    let l6 = *arg0
                                        .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                            }
                            let l8 = i32::from(
                                *arg0
                                    .add(24 + 7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l8 {
                                0 => {}
                                _ => {
                                    let l9 = *arg0
                                        .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(24 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                            }
                            let l11 = *arg0
                                .add(24 + 10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l12 = *arg0
                                .add(24 + 11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base17 = l11;
                            let len17 = l12;
                            for i in 0..len17 {
                                let base = base17
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l13 = *base.add(0).cast::<*mut u8>();
                                    let l14 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                    let l15 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l16 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base17,
                                len17 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l18 = *arg0
                                .add(24 + 12 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l19 = *arg0
                                .add(24 + 13 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base27 = l18;
                            let len27 = l19;
                            for i in 0..len27 {
                                let base = base27
                                    .add(i * (24 + 4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l20 = *base.add(0).cast::<*mut u8>();
                                    let l21 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                    let l22 = *base
                                        .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l23 = *base
                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base26 = l22;
                                    let len26 = l23;
                                    for i in 0..len26 {
                                        let base = base26
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l24 = *base.add(0).cast::<*mut u8>();
                                            let l25 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l24, l25, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base26,
                                        len26 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                            }
                            _rt::cabi_dealloc(
                                base27,
                                len27 * (24 + 4 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let l28 = *arg0
                                .add(24 + 14 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l29 = *arg0
                                .add(24 + 15 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base35 = l28;
                            let len35 = l29;
                            for i in 0..len35 {
                                let base = base35
                                    .add(i * (16 + 6 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l30 = i32::from(*base.add(0).cast::<u8>());
                                    match l30 {
                                        0 => {}
                                        _ => {
                                            let l31 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l32 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l31, l32, 1);
                                        }
                                    }
                                    let l33 = *base
                                        .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l34 = *base
                                        .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base35,
                                len35 * (16 + 6 * ::core::mem::size_of::<*const u8>()),
                                8,
                            );
                            let l36 = *arg0
                                .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l37 = *arg0
                                .add(24 + 17 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base40 = l36;
                            let len40 = l37;
                            for i in 0..len40 {
                                let base = base40
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l38 = *base.add(0).cast::<*mut u8>();
                                    let l39 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l38, l39, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base40,
                                len40 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l41 = *arg0
                                .add(24 + 18 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l42 = *arg0
                                .add(24 + 19 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base52 = l41;
                            let len52 = l42;
                            for i in 0..len52 {
                                let base = base52
                                    .add(i * (10 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l43 = *base.add(0).cast::<*mut u8>();
                                    let l44 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                    let l45 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l46 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l45, l46, 1);
                                    let l47 = i32::from(
                                        *base
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l47 {
                                        0 => {}
                                        _ => {
                                            let l48 = *base
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l49 = *base
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l48, l49, 1);
                                        }
                                    }
                                    let l50 = *base
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l51 = *base
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l50, l51, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base52,
                                len52 * (10 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l53 = *arg0
                                .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l54 = *arg0
                                .add(32 + 21 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base57 = l53;
                            let len57 = l54;
                            for i in 0..len57 {
                                let base = base57
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l55 = *base.add(0).cast::<*mut u8>();
                                    let l56 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l55, l56, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base57,
                                len57 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l58 = *arg0.add(8).cast::<*mut u8>();
                            let l59 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l58, l59, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_extract_metadata_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::extract_metadata(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        super::super::super::super::exports::athena::file_processor::detector::FileFormat::_lift(
                            arg2 as u8,
                        ),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let FileMetadata {
                                size: size3,
                                hash: hash3,
                                mime_type: mime_type3,
                                created_at: created_at3,
                                modified_at: modified_at3,
                                attributes: attributes3,
                            } = e;
                            *ptr2.add(8).cast::<i64>() = _rt::as_i64(size3);
                            let vec4 = (hash3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2
                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = (mime_type3.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr2
                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr2
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                            match created_at3 {
                                Some(e) => {
                                    *ptr2
                                        .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2
                                        .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr2
                                        .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                None => {
                                    *ptr2
                                        .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match modified_at3 {
                                Some(e) => {
                                    *ptr2
                                        .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(16 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2
                                        .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                None => {
                                    *ptr2
                                        .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec11 = attributes3;
                            let len11 = vec11.len();
                            let layout11 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec11.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result11 = if layout11.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout11).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout11);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec11.into_iter().enumerate() {
                                let base = result11
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t8_0, t8_1) = e;
                                    let vec9 = (t8_0.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *base.add(0).cast::<*mut u8>() = ptr9.cast_mut();
                                    let vec10 = (t8_1.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr10.cast_mut();
                                }
                            }
                            *ptr2
                                .add(16 + 11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len11;
                            *ptr2
                                .add(16 + 10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result11;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec12 = (e.into_bytes()).into_boxed_slice();
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            ::core::mem::forget(vec12);
                            *ptr2
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len12;
                            *ptr2.add(8).cast::<*mut u8>() = ptr12.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_extract_metadata<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(16).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                            let l5 = i32::from(
                                *arg0
                                    .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l5 {
                                0 => {}
                                _ => {
                                    let l6 = *arg0
                                        .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                            }
                            let l8 = i32::from(
                                *arg0
                                    .add(16 + 7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l8 {
                                0 => {}
                                _ => {
                                    let l9 = *arg0
                                        .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(16 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                            }
                            let l11 = *arg0
                                .add(16 + 10 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l12 = *arg0
                                .add(16 + 11 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base17 = l11;
                            let len17 = l12;
                            for i in 0..len17 {
                                let base = base17
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l13 = *base.add(0).cast::<*mut u8>();
                                    let l14 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                    let l15 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l16 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base17,
                                len17 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l18 = *arg0.add(8).cast::<*mut u8>();
                            let l19 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l18, l19, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Parse file and extract its content
                    fn parse_file(
                        buffer: _rt::Vec<u8>,
                        format_hint: Option<FileFormat>,
                    ) -> Result<ParsedFile, _rt::String>;
                    /// Extract metadata from file
                    fn extract_metadata(
                        buffer: _rt::Vec<u8>,
                        format: FileFormat,
                    ) -> Result<FileMetadata, _rt::String>;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_file_processor_parser_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:file-processor/parser@0.1.0#parse-file")] unsafe extern
                        "C" fn export_parse_file(arg0 : * mut u8, arg1 : usize, arg2 :
                        i32, arg3 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_parse_file_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "cabi_post_athena:file-processor/parser@0.1.0#parse-file")]
                        unsafe extern "C" fn _post_return_parse_file(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_parse_file::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "athena:file-processor/parser@0.1.0#extract-metadata")] unsafe
                        extern "C" fn export_extract_metadata(arg0 : * mut u8, arg1 :
                        usize, arg2 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_extract_metadata_cabi::<$ty > (arg0, arg1, arg2) } }
                        #[unsafe (export_name =
                        "cabi_post_athena:file-processor/parser@0.1.0#extract-metadata")]
                        unsafe extern "C" fn _post_return_extract_metadata(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_extract_metadata::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_file_processor_parser_0_1_0_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 32 + 22 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 32
                        + 22 * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// Content extraction utilities
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod extractor {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// Extracted string with context
                #[derive(Clone)]
                pub struct ExtractedString {
                    pub value: _rt::String,
                    pub offset: u64,
                    pub encoding: _rt::String,
                    pub suspicious: bool,
                }
                impl ::core::fmt::Debug for ExtractedString {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ExtractedString")
                            .field("value", &self.value)
                            .field("offset", &self.offset)
                            .field("encoding", &self.encoding)
                            .field("suspicious", &self.suspicious)
                            .finish()
                    }
                }
                /// Pattern types
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum PatternType {
                    Url,
                    IpAddress,
                    Domain,
                    Email,
                    Base64,
                    HexEncoded,
                    ObfuscatedCode,
                    CryptoWallet,
                    ApiKey,
                    Password,
                }
                impl ::core::fmt::Debug for PatternType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            PatternType::Url => {
                                f.debug_tuple("PatternType::Url").finish()
                            }
                            PatternType::IpAddress => {
                                f.debug_tuple("PatternType::IpAddress").finish()
                            }
                            PatternType::Domain => {
                                f.debug_tuple("PatternType::Domain").finish()
                            }
                            PatternType::Email => {
                                f.debug_tuple("PatternType::Email").finish()
                            }
                            PatternType::Base64 => {
                                f.debug_tuple("PatternType::Base64").finish()
                            }
                            PatternType::HexEncoded => {
                                f.debug_tuple("PatternType::HexEncoded").finish()
                            }
                            PatternType::ObfuscatedCode => {
                                f.debug_tuple("PatternType::ObfuscatedCode").finish()
                            }
                            PatternType::CryptoWallet => {
                                f.debug_tuple("PatternType::CryptoWallet").finish()
                            }
                            PatternType::ApiKey => {
                                f.debug_tuple("PatternType::ApiKey").finish()
                            }
                            PatternType::Password => {
                                f.debug_tuple("PatternType::Password").finish()
                            }
                        }
                    }
                }
                impl PatternType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> PatternType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => PatternType::Url,
                            1 => PatternType::IpAddress,
                            2 => PatternType::Domain,
                            3 => PatternType::Email,
                            4 => PatternType::Base64,
                            5 => PatternType::HexEncoded,
                            6 => PatternType::ObfuscatedCode,
                            7 => PatternType::CryptoWallet,
                            8 => PatternType::ApiKey,
                            9 => PatternType::Password,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Suspicious pattern
                #[derive(Clone)]
                pub struct SuspiciousPattern {
                    pub pattern_type: PatternType,
                    pub value: _rt::String,
                    pub context: Option<_rt::String>,
                    pub confidence: f32,
                }
                impl ::core::fmt::Debug for SuspiciousPattern {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SuspiciousPattern")
                            .field("pattern-type", &self.pattern_type)
                            .field("value", &self.value)
                            .field("context", &self.context)
                            .field("confidence", &self.confidence)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_extract_strings_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::extract_strings(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        arg2 as u32,
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec6 = result1;
                    let len6 = vec6.len();
                    let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec6.len() * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                    let result6 = if layout6.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout6);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec6.into_iter().enumerate() {
                        let base = result6
                            .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let ExtractedString {
                                value: value3,
                                offset: offset3,
                                encoding: encoding3,
                                suspicious: suspicious3,
                            } = e;
                            let vec4 = (value3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i64>() = _rt::as_i64(offset3);
                            let vec5 = (encoding3.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *base
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr5.cast_mut();
                            *base
                                .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (match suspicious3 {
                                true => 1,
                                false => 0,
                            }) as u8;
                        }
                    }
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                    *ptr2.add(0).cast::<*mut u8>() = result6;
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_extract_strings<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base6 = l0;
                    let len6 = l1;
                    for i in 0..len6 {
                        let base = base6
                            .add(i * (16 + 4 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l4 = *base
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *base
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base6,
                        len6 * (16 + 4 * ::core::mem::size_of::<*const u8>()),
                        8,
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_extract_suspicious_patterns_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::extract_suspicious_patterns(
                        _rt::string_lift(bytes0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec6 = result1;
                    let len6 = vec6.len();
                    let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec6.len() * (7 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result6 = if layout6.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout6);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec6.into_iter().enumerate() {
                        let base = result6
                            .add(i * (7 * ::core::mem::size_of::<*const u8>()));
                        {
                            let SuspiciousPattern {
                                pattern_type: pattern_type3,
                                value: value3,
                                context: context3,
                                confidence: confidence3,
                            } = e;
                            *base.add(0).cast::<u8>() = (pattern_type3.clone() as i32)
                                as u8;
                            let vec4 = (value3.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                            match context3 {
                                Some(e) => {
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                None => {
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            *base
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<f32>() = _rt::as_f32(confidence3);
                        }
                    }
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                    *ptr2.add(0).cast::<*mut u8>() = result6;
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_extract_suspicious_patterns<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base7 = l0;
                    let len7 = l1;
                    for i in 0..len7 {
                        let base = base7
                            .add(i * (7 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l3 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                            let l4 = i32::from(
                                *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l4 {
                                0 => {}
                                _ => {
                                    let l5 = *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                            }
                        }
                    }
                    _rt::cabi_dealloc(
                        base7,
                        len7 * (7 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                pub trait Guest {
                    /// Extract strings from file
                    fn extract_strings(
                        buffer: _rt::Vec<u8>,
                        min_length: u32,
                    ) -> _rt::Vec<ExtractedString>;
                    /// Extract suspicious patterns from content
                    fn extract_suspicious_patterns(
                        content: _rt::String,
                    ) -> _rt::Vec<SuspiciousPattern>;
                }
                #[doc(hidden)]
                macro_rules! __export_athena_file_processor_extractor_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "athena:file-processor/extractor@0.1.0#extract-strings")] unsafe
                        extern "C" fn export_extract_strings(arg0 : * mut u8, arg1 :
                        usize, arg2 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_extract_strings_cabi::<$ty > (arg0, arg1, arg2) } }
                        #[unsafe (export_name =
                        "cabi_post_athena:file-processor/extractor@0.1.0#extract-strings")]
                        unsafe extern "C" fn _post_return_extract_strings(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_extract_strings::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "athena:file-processor/extractor@0.1.0#extract-suspicious-patterns")]
                        unsafe extern "C" fn export_extract_suspicious_patterns(arg0 : *
                        mut u8, arg1 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*::
                        _export_extract_suspicious_patterns_cabi::<$ty > (arg0, arg1) } }
                        #[unsafe (export_name =
                        "cabi_post_athena:file-processor/extractor@0.1.0#extract-suspicious-patterns")]
                        unsafe extern "C" fn
                        _post_return_extract_suspicious_patterns(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_extract_suspicious_patterns::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_athena_file_processor_extractor_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 2 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 2
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub use alloc_crate::string::String;
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::alloc;
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }
    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }
    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }
    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_file_processor_component_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::athena::file_processor::detector::__export_athena_file_processor_detector_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::athena::file_processor::detector); $($path_to_types_root)*::
        exports::athena::file_processor::validator::__export_athena_file_processor_validator_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::athena::file_processor::validator); $($path_to_types_root)*::
        exports::athena::file_processor::parser::__export_athena_file_processor_parser_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::athena::file_processor::parser);
        $($path_to_types_root)*::
        exports::athena::file_processor::extractor::__export_athena_file_processor_extractor_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::athena::file_processor::extractor);
    };
}
#[doc(inline)]
pub(crate) use __export_file_processor_component_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:athena:file-processor@0.1.0:file-processor-component:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1897] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xda\x0d\x01A\x02\x01\
A\x09\x01B\x0a\x01m\x1e\x04pe32\x04pe64\x05elf32\x05elf64\x05macho\x03pdf\x04doc\
x\x04xlsx\x04pptx\x03odt\x03zip\x03rar\x06sevenz\x03tar\x04gzip\x0ajavascript\x0a\
typescript\x06python\x0apowershell\x05batch\x05shell\x03php\x04ruby\x04html\x03x\
ml\x04json\x03css\x0aplain-text\x06binary\x07unknown\x04\0\x0bfile-format\x03\0\0\
\x01p}\x01ks\x01@\x02\x06buffer\x02\x08filename\x03\0\x01\x04\0\x0ddetect-format\
\x01\x04\x01@\x01\x06buffer\x02\0\x7f\x04\0\x0cis-text-file\x01\x05\x01@\x01\x06\
format\x01\0s\x04\0\x0dget-mime-type\x01\x06\x04\0$athena:file-processor/detecto\
r@0.1.0\x05\0\x02\x03\0\0\x0bfile-format\x01B\x08\x02\x03\x02\x01\x01\x04\0\x0bf\
ile-format\x03\0\0\x01ps\x01r\x06\x08is-valid\x7f\x0cformat-valid\x7f\x0asize-va\
lid\x7f\x0ccontent-safe\x7f\x06errors\x02\x08warnings\x02\x04\0\x11validation-re\
sult\x03\0\x03\x01p}\x01@\x02\x06buffer\x05\x06format\x01\0\x04\x04\0\x0dvalidat\
e-file\x01\x06\x04\0%athena:file-processor/validator@0.1.0\x05\x02\x01B\x20\x02\x03\
\x02\x01\x01\x04\0\x0bfile-format\x03\0\0\x01ps\x01r\x05\x04names\x06offsetw\x04\
sizew\x07entropyu\x0dsection-flags\x02\x04\0\x0cfile-section\x03\0\x03\x01ks\x01\
r\x05\x04name\x05\x06format\x01\x06offsetw\x04sizew\x04hashs\x04\0\x0dembedded-f\
ile\x03\0\x06\x01m\x04\x03low\x06medium\x04high\x08critical\x04\0\x13suspicious-\
severity\x03\0\x08\x01r\x05\x0eindicator-types\x0bdescriptions\x08severity\x09\x08\
location\x05\x08evidences\x04\0\x14suspicious-indicator\x03\0\x0a\x01k\x7f\x01r\x04\
\x0fvalid-structure\x7f\x0echecksum-valid\x0c\x0fsignature-valid\x0c\x06issues\x02\
\x04\0\x0efile-integrity\x03\0\x0d\x01o\x02ss\x01p\x0f\x01r\x06\x04sizew\x04hash\
s\x09mime-types\x0acreated-at\x05\x0bmodified-at\x05\x0aattributes\x10\x04\0\x0d\
file-metadata\x03\0\x11\x01p\x04\x01p\x07\x01p\x0b\x01r\x07\x06format\x01\x08met\
adata\x12\x08sections\x13\x0eembedded-files\x14\x07strings\x02\x15suspicious-ind\
icators\x15\x09integrity\x0e\x04\0\x0bparsed-file\x03\0\x16\x01p}\x01k\x01\x01j\x01\
\x17\x01s\x01@\x02\x06buffer\x18\x0bformat-hint\x19\0\x1a\x04\0\x0aparse-file\x01\
\x1b\x01j\x01\x12\x01s\x01@\x02\x06buffer\x18\x06format\x01\0\x1c\x04\0\x10extra\
ct-metadata\x01\x1d\x04\0\"athena:file-processor/parser@0.1.0\x05\x03\x01B\x0e\x01\
r\x04\x05values\x06offsetw\x08encodings\x0asuspicious\x7f\x04\0\x10extracted-str\
ing\x03\0\0\x01m\x0a\x03url\x0aip-address\x06domain\x05email\x06base64\x0bhex-en\
coded\x0fobfuscated-code\x0dcrypto-wallet\x07api-key\x08password\x04\0\x0cpatter\
n-type\x03\0\x02\x01ks\x01r\x04\x0cpattern-type\x03\x05values\x07context\x04\x0a\
confidencev\x04\0\x12suspicious-pattern\x03\0\x05\x01p}\x01p\x01\x01@\x02\x06buf\
fer\x07\x0amin-lengthy\0\x08\x04\0\x0fextract-strings\x01\x09\x01p\x06\x01@\x01\x07\
contents\0\x0a\x04\0\x1bextract-suspicious-patterns\x01\x0b\x04\0%athena:file-pr\
ocessor/extractor@0.1.0\x05\x04\x04\04athena:file-processor/file-processor-compo\
nent@0.1.0\x04\0\x0b\x1e\x01\0\x18file-processor-component\x03\0\0\0G\x09produce\
rs\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.\
41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
