var p=Object.defineProperty;var f=(h,e,t)=>e in h?p(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var u=(h,e,t)=>f(h,typeof e!="symbol"?e+"":e,t);import{a as c,i as d,m as w}from"./index-C4Q2lgHl.js";import{a as T}from"./aiService-BcH-L2s_.js";import{l as g,e as y}from"./vendor-B78zZivC.js";import"./vendor-solid-ZF9XUUOY.js";class A{constructor(){u(this,"listeners",new Map);u(this,"progressHistory",new Map);u(this,"startTimes",new Map);u(this,"estimatedDurations",new Map);u(this,"batchedUpdates",new Map);u(this,"batchTimer",null);this.setupEventListeners(),this.initializeEstimates()}initializeEstimates(){this.estimatedDurations.set("static",5e3),this.estimatedDurations.set("yara",8e3),this.estimatedDurations.set("wasm",15e3),this.estimatedDurations.set("ai",3e4),this.estimatedDurations.set("dynamic",6e4)}setupEventListeners(){g("analysis-progress",e=>{this.handleProgressUpdate(e.payload)}),g("analysis-stream",e=>{this.handleStreamingResult(e.payload)}),g("analysis-phase",e=>{this.handlePhaseChange(e.payload)})}handleProgressUpdate(e){const t=`${e.fileId}-${e.analysisType}`;this.progressHistory.has(t)||this.progressHistory.set(t,[]),this.progressHistory.get(t).push(e),e.progress>0&&this.updateTimeEstimate(e),c.updateProgress({[`${e.analysisType}Analysis`]:{status:"running",progress:e.progress,phase:e.phase,message:e.message,estimatedTimeRemaining:e.estimatedTimeRemaining}}),this.notifyListeners(e.fileId,e)}handleStreamingResult(e){const t=c.state.streamingResults||{},s=t[e.fileId]||{},a=s[e.analysisType]||[];a.push(e.chunk),c.updateStreamingResults({...t,[e.fileId]:{...s,[e.analysisType]:a}}),e.isComplete&&c.updateProgress({[`${e.analysisType}Analysis`]:{status:"completed",progress:100}})}handlePhaseChange(e){y("ui-phase-change",e)}updateTimeEstimate(e){const t=`${e.fileId}-${e.analysisType}`,s=this.startTimes.get(t);if(!s){this.startTimes.set(t,Date.now());return}const a=Date.now()-s,i=a/(e.progress/100),n=i-a;this.estimatedDurations.set(e.analysisType,i),e.estimatedTimeRemaining=Math.max(0,Math.round(n))}startAnalysis(e,t){const s=`${e}-${t}`;this.startTimes.set(s,Date.now()),this.emitProgress({fileId:e,analysisType:t,phase:"initializing",progress:0,message:`Starting ${t} analysis...`,estimatedTimeRemaining:this.estimatedDurations.get(t)})}updateProgress(e,t,s,a,i,n){this.emitProgress({fileId:e,analysisType:t,phase:a,progress:s,message:i,details:n})}completeAnalysis(e,t,s){const a=`${e}-${t}`,i=this.startTimes.get(a);if(i){const n=Date.now()-i,l=this.estimatedDurations.get(t)||n;this.estimatedDurations.set(t,(l+n)/2)}this.emitProgress({fileId:e,analysisType:t,phase:"completed",progress:100,message:`${t} analysis completed`,details:s}),this.startTimes.delete(a),this.progressHistory.delete(a)}emitProgress(e){y("progress-update",e),this.handleProgressUpdate(e)}streamResult(e,t,s,a=!1){const i={fileId:e,analysisType:t,chunk:s,isComplete:a};y("stream-result",i),this.handleStreamingResult(i)}subscribe(e,t){return this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(t),()=>{const s=this.listeners.get(e);if(s){const a=s.indexOf(t);a>-1&&s.splice(a,1)}}}notifyListeners(e,t){const s=this.listeners.get(e);s&&s.forEach(a=>a(t))}getProgress(e){const t={};return["static","yara","wasm","ai","dynamic"].forEach(s=>{const a=`${e}-${s}`,i=this.progressHistory.get(a);if(i&&i.length>0){const n=i[i.length-1];t[s]=n!==void 0?n.progress:0}else t[s]=0}),t}getEstimatedTotalTime(e){return e.reduce((t,s)=>t+(this.estimatedDurations.get(s)||1e4),0)}formatTime(e){const t=Math.floor(e/1e3);if(t<60)return`${t}s`;const s=Math.floor(t/60),a=t%60;if(s<60)return`${s}m ${a}s`;const i=Math.floor(s/60),n=s%60;return`${i}h ${n}m`}batchProgressUpdate(e){const t=`${e.fileId}-${e.analysisType}`;this.batchedUpdates.set(t,e),this.batchTimer||(this.batchTimer=setTimeout(()=>{this.flushBatchedUpdates()},100))}flushBatchedUpdates(){this.batchedUpdates.forEach(e=>{this.handleProgressUpdate(e)}),this.batchedUpdates.clear(),this.batchTimer=null}}const r=new A;class v{constructor(){u(this,"tasks",new Map);u(this,"queues",new Map);u(this,"activeCount",new Map);u(this,"bulkheads",new Map);u(this,"cancellationTokens",new Map);this.initializeBulkheads()}initializeBulkheads(){this.bulkheads.set("static",{maxConcurrent:3,queueSize:10,timeout:3e4}),this.bulkheads.set("dynamic",{maxConcurrent:1,queueSize:5,timeout:3e5}),this.bulkheads.set("ai",{maxConcurrent:2,queueSize:20,timeout:6e4}),this.bulkheads.set("yara",{maxConcurrent:2,queueSize:10,timeout:45e3}),this.bulkheads.set("wasm",{maxConcurrent:2,queueSize:10,timeout:6e4});for(const[e]of this.bulkheads)this.queues.set(e,[]),this.activeCount.set(e,0)}async analyzeFile(e){const t=["static","yara","wasm","ai"];for(const s of t){const a={id:`${e.id}-${s}-${Date.now()}`,fileId:e.id,type:s,status:"pending"};this.tasks.set(a.id,a),await this.enqueueTask(a)}c.startAnalysis(e.id)}async enqueueTask(e){const t=this.queues.get(e.type),s=this.bulkheads.get(e.type);if(!t||!s)throw new Error(`Invalid task type: ${e.type}`);(this.activeCount.get(e.type)||0)<s.maxConcurrent?this.runTask(e):t.length<s.queueSize?t.push(e):(e.status="failed",e.error=new Error("Analysis queue is full"),this.handleTaskCompletion(e))}async runTask(e){const t=this.bulkheads.get(e.type),s=new AbortController;this.cancellationTokens.set(e.id,s),this.activeCount.set(e.type,(this.activeCount.get(e.type)||0)+1),e.status="running",e.startTime=Date.now();const a=setTimeout(()=>{e.status==="running"&&(s.abort(),e.status="failed",e.error=new Error(`Analysis timed out after ${t.timeout}ms`),this.handleTaskCompletion(e))},t.timeout);try{const i=await this.executeAnalysis(e,s.signal);clearTimeout(a),s.signal.aborted||(e.status="completed",e.result=i,e.endTime=Date.now())}catch(i){clearTimeout(a),s.signal.aborted||(e.status="failed",e.error=i,e.endTime=Date.now())}finally{this.cancellationTokens.delete(e.id),this.handleTaskCompletion(e)}}async executeAnalysis(e,t){const s=c.state.files.find(i=>i.id===e.fileId);if(!s)throw new Error("File not found");const a=`${e.type}Analysis`;switch(c.updateProgress({[a]:{status:"running",progress:0}}),e.type){case"static":return this.executeStaticAnalysis(s,t);case"yara":return this.executeYaraAnalysis(s,t);case"wasm":return this.executeWasmAnalysis(s,t);case"ai":return this.executeAIAnalysis(s,t);default:throw new Error(`Unknown analysis type: ${e.type}`)}}async executeStaticAnalysis(e,t){if(e.analysisResult)return e.analysisResult;r.startAnalysis(e.id,"static"),r.updateProgress(e.id,"static",10,"reading","Reading file contents...");const s=await d("analyze_file",{filePath:e.path});return r.updateProgress(e.id,"static",90,"analyzing","Analyzing file structure..."),r.completeAnalysis(e.id,"static",s),s}async executeYaraAnalysis(e,t){r.startAnalysis(e.id,"yara"),r.updateProgress(e.id,"yara",20,"loading-rules","Loading YARA rules..."),r.updateProgress(e.id,"yara",50,"scanning","Scanning file with YARA rules...");const s=await d("scan_file_with_yara",{filePath:e.path});return r.updateProgress(e.id,"yara",80,"processing","Processing rule matches..."),r.completeAnalysis(e.id,"yara",s),s}async executeWasmAnalysis(e,t){r.startAnalysis(e.id,"wasm"),r.updateProgress(e.id,"wasm",10,"loading","Loading WASM security modules...");const s=["analysis-engine","crypto","deobfuscator","file-processor","pattern-matcher"];for(let i=0;i<s.length;i++){const n=10+i*15;r.updateProgress(e.id,"wasm",n,"analyzing",`Running ${s[i]} module...`),await new Promise(l=>setTimeout(l,200))}const a=await d("analyze_file_with_wasm",{filePath:e.path});if(a.wasm_analyses)for(const i of a.wasm_analyses)r.streamResult(e.id,"wasm",i,!1);return r.completeAnalysis(e.id,"wasm",a),a}async executeAIAnalysis(e,t){r.startAnalysis(e.id,"ai");const s={fileHash:e.hash,fileName:e.name,filePath:e.path,fileSize:e.size,fileType:e.type,providers:["claude","gpt4","deepseek","gemini","mistral","llama"],analysisType:"comprehensive",priority:"high"};r.updateProgress(e.id,"ai",5,"preparing","Preparing AI analysis request...");const a=(l,o)=>{const m=5+o*.9;r.updateProgress(e.id,"ai",m,"analyzing",`Analyzing with ${l}...`),r.streamResult(e.id,"ai",{provider:l,progress:o,timestamp:Date.now()},!1)},i=await T.analyzeWithEnsemble(s,"voting",a),n={malwareScore:i.consensus.confidence*100,threats:i.consensus.signatures,aiAnalysis:i.individual.reduce((l,o)=>(l[o.provider]={score:o.confidence*100,summary:`Threat Level: ${o.threatLevel}`,details:o.recommendations.join(`
`)},l),{})};return c.setAnalysisResults(e.id,n),r.completeAnalysis(e.id,"ai",i),i}handleTaskCompletion(e){const t=this.activeCount.get(e.type)||0;this.activeCount.set(e.type,Math.max(0,t-1));const s=this.queues.get(e.type);if(s&&s.length>0){const n=s.shift();n&&this.runTask(n)}const a=Array.from(this.tasks.values()).filter(n=>n.fileId===e.fileId);if(a.every(n=>n.status==="completed"||n.status==="failed")){const l=a.filter(o=>o.status==="completed").filter(o=>{var m;return(m=o.result)==null?void 0:m.confidence}).map(o=>o.result.confidence);l.length>0&&l.reduce((o,m)=>o+m,0)/l.length,c.updateFileStatus(e.fileId,"completed")}}cancelAnalysis(e){const t=Array.from(this.tasks.values()).filter(s=>s.fileId===e&&s.status==="running");for(const s of t){const a=this.cancellationTokens.get(s.id);a&&a.abort()}for(const[s,a]of this.queues){const i=a.filter(n=>n.fileId!==e);this.queues.set(s,i)}c.updateFileStatus(e,"error")}getTaskStatus(e){const t=Array.from(this.tasks.values()).filter(s=>s.fileId===e);return{total:t.length,completed:t.filter(s=>s.status==="completed").length,failed:t.filter(s=>s.status==="failed").length,running:t.filter(s=>s.status==="running").length,pending:t.filter(s=>s.status==="pending").length,tasks:t}}getQueueStatus(){var t;const e={};for(const[s,a]of this.queues)e[s]={queueLength:a.length,activeCount:this.activeCount.get(s)||0,maxConcurrent:((t=this.bulkheads.get(s))==null?void 0:t.maxConcurrent)||0};return e}getResourceUsage(){const e=Array.from(this.activeCount.values()).reduce((s,a)=>s+a,0),t=Array.from(this.queues.values()).reduce((s,a)=>s+a.length,0);return{activeAnalyses:e,queuedAnalyses:t,memoryUsage:w.getTotalAllocated(),bulkheadStatus:this.getQueueStatus()}}}const q=new v;export{q as analysisCoordinator};
