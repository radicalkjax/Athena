import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
/**
 * Integration Test: Complete Malware Analysis Workflow
 * Tests the full flow from file upload through analysis to results display
 * 
 * SKIPPED: End-to-end workflow test requiring multiple services and components
 * to work together. Re-enable when malware analysis pipeline is fully implemented.
 */

// Mock database before any imports
vi.mock('@/config/database');
vi.mock('@/models');
vi.mock('@/services/container-db');
vi.mock('@/services/fileManager');
vi.mock('@/services/analysisService');
vi.mock('@/services/container');

import React from 'react';
import { fireEvent, waitFor, within } from '@testing-library/react-native';
import { View, Text, TouchableOpacity } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { renderWithProviders, resetStores, mockServices } from './setup';
import { useAppStore } from '@/store';
import * as fileManagerService from '@/services/fileManager';
import * as analysisService from '@/services/analysisService';
import * as containerService from '@/services/container';


// Import the main app component (assuming it exists)
// For this test, we'll mock a simplified version
const MainApp = () => {
  const { 
    malwareFiles, 
    selectedMalwareId, 
    isAnalyzing, 
    analysisResults,
    selectMalwareFile,
    addMalwareFile,
    setIsAnalyzing,
    addAnalysisResult 
  } = useAppStore();

  const handleFileUpload = async () => {
    const file = await (fileManagerService as any).pickFile();
    if (file) {
      addMalwareFile(file);
      selectMalwareFile(file.id);
    }
  };

  const handleAnalyze = async () => {
    if (!selectedMalwareId) return;
    
    const file = malwareFiles.find(f => f.id === selectedMalwareId);
    if (!file) return;

    setIsAnalyzing(true);
    try {
      const results = await (analysisService as any).analyzeFile(file, {
        deepAnalysis: true,
        saveResults: true
      });
      addAnalysisResult(results);
    } catch (error) {
      console.error('Analysis failed:', error);
    } finally {
      setIsAnalyzing(false);
    }
  };

  return (
    <NavigationContainer>
      <View testID="main-app">
        <TouchableOpacity testID="upload-button" onPress={handleFileUpload}>
          <Text>Upload</Text>
        </TouchableOpacity>
        
        {malwareFiles.map(file => (
          <View key={file.id} testID={`file-${file.id}`}>
            <Text>{file.name}</Text>
            <TouchableOpacity onPress={() => selectMalwareFile(file.id)}>
              <Text>Select</Text>
            </TouchableOpacity>
          </View>
        ))}
        
        {selectedMalwareId && (
          <TouchableOpacity testID="analyze-button" onPress={handleAnalyze}>
            <Text>Analyze</Text>
          </TouchableOpacity>
        )}
        
        {isAnalyzing && <Text testID="analyzing-indicator">Analyzing...</Text>}
        
        {analysisResults && analysisResults.length > 0 && (
          <View testID="analysis-results">
            <Text testID="analysis-report">{analysisResults[0].analysisReport}</Text>
            {analysisResults[0].vulnerabilities?.map((vuln, index) => (
              <Text key={index} testID={`vulnerability-${index}`}>
                {vuln.name}: {vuln.severity}
              </Text>
            ))}
          </View>
        )}
      </View>
    </NavigationContainer>
  );
};

// Mock all services
vi.mock('@/services/fileManager');
vi.mock('@/services/analysisService');
vi.mock('@/services/container');
vi.mock('@/services/openai');
vi.mock('@/services/deepseek');
vi.mock('@/services/claude');
vi.mock('@/services/container-db');
vi.mock('@/models');
vi.mock('@/config/database');

describe.skip('Malware Analysis Workflow Integration', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    resetStores();
    vi.clearAllMocks();
    
    // Setup service mocks
    Object.assign(fileManagerService, mockServices.fileManager);
    Object.assign(analysisService, mockServices.analysisService);
    Object.assign(containerService, mockServices.containerService);
  });
  
  afterEach(() => {
    vi.clearAllTimers();
    vi.useRealTimers();
  });

  afterEach(() => {
    vi.clearAllTimers();
  });

  describe('Complete Analysis Flow', () => {
    it('should complete full malware analysis workflow', async () => {
      const { getByTestId, getByText, queryByTestId } = renderWithProviders(<MainApp />);
      
      // Step 1: Upload a file
      expect(getByTestId('upload-button')).toBeTruthy();
      fireEvent.press(getByTestId('upload-button'));
      
      // Wait for file to be uploaded and displayed
      await waitFor(() => {
        expect(fileManagerService.pickFile).toHaveBeenCalled();
        expect(getByText('malicious.exe')).toBeTruthy();
      }, { timeout: 3000 });
      
      // Verify file was added to store
      const storeState = useAppStore.getState();
      expect(storeState.malwareFiles).toHaveLength(1);
      expect(storeState.malwareFiles[0].name).toBe('malicious.exe');
      
      // Step 2: File should be automatically selected after upload
      expect(storeState.selectedMalwareId).toBe('test-file-123');
      expect(getByTestId('analyze-button')).toBeTruthy();
      
      // Step 3: Start analysis
      fireEvent.press(getByTestId('analyze-button'));
      
      // Should show analyzing indicator
      await waitFor(() => {
        expect(getByTestId('analyzing-indicator')).toBeTruthy();
      });
      
      // Step 4: Wait for analysis to complete
      await waitFor(() => {
        expect(queryByTestId('analyzing-indicator')).toBeFalsy();
        expect(getByTestId('analysis-results')).toBeTruthy();
      }, { timeout: 5000 });
      
      // Step 5: Verify analysis results are displayed
      const resultsContainer = getByTestId('analysis-results');
      const reportElement = within(resultsContainer).getByTestId('analysis-report');
      expect(reportElement).toBeTruthy();
      
      // Get the analysis report text
      const reportText = reportElement.props.children;
      expect(reportText).toContain('Risk Score: 8.5');
      expect(reportText).toContain('Trojan.Generic');
      
      // Check for vulnerabilities
      const vulnerability = within(resultsContainer).getByTestId('vulnerability-0');
      expect(vulnerability).toBeTruthy();
      expect(vulnerability.props.children).toEqual(['Buffer Overflow', ': ', 'high']);
      
      // Verify the complete flow
      expect((fileManagerService as any).pickFile).toHaveBeenCalledTimes(1);
      expect((analysisService as any).analyzeFile).toHaveBeenCalledWith(
        expect.objectContaining({
          id: 'test-file-123',
          name: 'malicious.exe'
        }),
        expect.objectContaining({
          deepAnalysis: true,
          saveResults: true
        })
      );
    });

    it('should handle analysis failure gracefully', async () => {
      // Mock analysis to fail
      (analysisService as any).analyzeFile = vi.fn().mockRejectedValue(new Error('Analysis service unavailable'));
      
      const { getByTestId, getByText, queryByTestId } = renderWithProviders(<MainApp />);
      
      // Upload file
      fireEvent.press(getByTestId('upload-button'));
      await waitFor(() => expect(getByText('malicious.exe')).toBeTruthy());
      
      // Start analysis
      fireEvent.press(getByTestId('analyze-button'));
      
      // Should show and hide analyzing indicator
      await waitFor(() => expect(getByTestId('analyzing-indicator')).toBeTruthy());
      await waitFor(() => expect(queryByTestId('analyzing-indicator')).toBeFalsy());
      
      // Should not show results
      expect(queryByTestId('analysis-results')).toBeFalsy();
      
      // Store should reflect the error state
      const storeState = useAppStore.getState();
      expect(storeState.isAnalyzing).toBe(false);
      expect(storeState.analysisResults).toEqual([]);
    });

    it('should handle multiple file uploads and selections', async () => {
      const { getByTestId, getByText } = renderWithProviders(<MainApp />);
      
      // Upload first file
      (fileManagerService.pickFile as jest.Mock).mockResolvedValueOnce({
        id: 'file-1',
        name: 'virus1.exe',
        size: 1024,
        type: 'application/x-msdownload',
        uri: 'file:///test/virus1.exe',
        content: ''
      });
      
      fireEvent.press(getByTestId('upload-button'));
      await waitFor(() => expect(getByText('virus1.exe')).toBeTruthy());
      
      // Upload second file
      (fileManagerService.pickFile as jest.Mock).mockResolvedValueOnce({
        id: 'file-2',
        name: 'virus2.exe',
        size: 2048,
        type: 'application/x-msdownload',
        uri: 'file:///test/virus2.exe',
        content: ''
      });
      
      fireEvent.press(getByTestId('upload-button'));
      await waitFor(() => expect(getByText('virus2.exe')).toBeTruthy());
      
      // Verify both files are in the store
      const storeState = useAppStore.getState();
      expect(storeState.malwareFiles).toHaveLength(2);
      
      // Select first file and analyze
      const file1Container = getByTestId('file-file-1');
      fireEvent.press(within(file1Container).getByText('Select'));
      
      expect(useAppStore.getState().selectedMalwareId).toBe('file-1');
      
      // Analyze first file
      fireEvent.press(getByTestId('analyze-button'));
      await waitFor(() => expect(getByTestId('analysis-results')).toBeTruthy());
      
      // Select second file
      const file2Container = getByTestId('file-file-2');
      fireEvent.press(within(file2Container).getByText('Select'));
      
      expect(useAppStore.getState().selectedMalwareId).toBe('file-2');
    });
  });

  describe('State Management', () => {
    it('should properly manage state throughout the workflow', async () => {
      const { getByTestId, getByText } = renderWithProviders(<MainApp />);
      
      // Initial state
      let state = useAppStore.getState();
      expect(state.malwareFiles).toHaveLength(0);
      expect(state.selectedMalwareId).toBeNull();
      expect(state.isAnalyzing).toBe(false);
      expect(state.analysisResults).toHaveLength(0);
      
      // After file upload
      fireEvent.press(getByTestId('upload-button'));
      await waitFor(() => expect(getByText('malicious.exe')).toBeTruthy());
      
      state = useAppStore.getState();
      expect(state.malwareFiles).toHaveLength(1);
      expect(state.selectedMalwareId).toBe('test-file-123');
      
      // During analysis
      fireEvent.press(getByTestId('analyze-button'));
      await waitFor(() => {
        state = useAppStore.getState();
        expect(state.isAnalyzing).toBe(true);
      });
      
      // After analysis
      await waitFor(() => expect(getByTestId('analysis-results')).toBeTruthy());
      
      state = useAppStore.getState();
      expect(state.isAnalyzing).toBe(false);
      expect(state.analysisResults).toBeTruthy();
      expect(state.analysisResults.length).toBeGreaterThan(0);
      expect(state.analysisResults[0].malwareId).toBe('test-file-123');
    });
  });

  describe('Performance', () => {
    it('should complete workflow within acceptable time limits', async () => {
      const startTime = Date.now();
      const { getByTestId, getByText } = renderWithProviders(<MainApp />);
      
      // Upload file
      fireEvent.press(getByTestId('upload-button'));
      await waitFor(() => expect(getByText('malicious.exe')).toBeTruthy());
      
      // Analyze
      fireEvent.press(getByTestId('analyze-button'));
      await waitFor(() => expect(getByTestId('analysis-results')).toBeTruthy());
      
      const endTime = Date.now();
      const totalTime = endTime - startTime;
      
      // Total workflow should complete within 2 seconds
      expect(totalTime).toBeLessThan(2000);
    });
  });
});